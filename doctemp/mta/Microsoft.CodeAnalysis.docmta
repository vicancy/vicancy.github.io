{
  "Namespaces": [
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.Symbols",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.Collections",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.Instrumentation",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.RuntimeMembers",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.InternalUtilities",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.Syntax",
      "XmlDocumentation": ""
    },
    {
      "Classes": [
        {
          "Methods": [],
          "Syntax": {
            "Content": "public class TextChangeEventArgs",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs\">\r\n    <summary>\r\n    Represents state for a TextChanged event.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.TextChangeEventArgs\">\r\n    <summary>\r\n    Represents state for a TextChanged event.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "protected virtual bool ContentEqualsImpl(SourceText other)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Implements equality comparison of the content of two different instances of <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ContentEqualsImpl(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Implements equality comparison of the content of two different instances of <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static SourceText From(string text, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.From(System.String,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Constructs a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> from text in a string.\r\n    </summary>\r\n    <param name=\"text\">Text.</param>\r\n    <param name=\"encoding\">\r\n    Encoding of the file that the <paramref name=\"text\"/> was read from or is going to be saved to.\r\n    <c>null</c> if the encoding is unspecified.\r\n    If the encoding is not specified the resulting <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> isn't debuggable.\r\n    If an encoding-less <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> is written to a file a <see cref=\"!:Encoding.UTF8\"/> shall be used as a default.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"text\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"checksumAlgorithm\"/> is not supported.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.From(System.String,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.From(System.String,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Constructs a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> from text in a string.\r\n    </summary>\r\n    <param name=\"text\">Text.</param>\r\n    <param name=\"encoding\">\r\n    Encoding of the file that the <paramref name=\"text\"/> was read from or is going to be saved to.\r\n    <c>null</c> if the encoding is unspecified.\r\n    If the encoding is not specified the resulting <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> isn't debuggable.\r\n    If an encoding-less <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> is written to a file a <see cref=\"!:Encoding.UTF8\"/> shall be used as a default.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"text\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"checksumAlgorithm\"/> is not supported.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual IReadOnlyList<TextChange> GetTextChanges(SourceText oldText)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Gets the set of <see cref=\"T:TextChange\"/> that describe how the text changed\r\n    between this text and an older version. This may be multiple detailed changes \r\n    or a single change encompassing the entire text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetTextChanges(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Gets the set of <see cref=\"T:TextChange\"/> that describe how the text changed\r\n    between this text and an older version. This may be multiple detailed changes \r\n    or a single change encompassing the entire text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public void Write(TextWriter textWriter, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,CancellationToken)\">\r\n    <summary>\r\n    Write this <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> to a text writer.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,CancellationToken)\">\r\n    <summary>\r\n    Write this <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> to a text writer.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual SourceText GetSubText(TextSpan span)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> that contains the characters in the specified span of this text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> that contains the characters in the specified span of this text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Write a span of text to a text writer.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Write(TextWriter,Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Write a span of text to a text writer.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SourceText GetSubText(int start)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)\">\r\n    <summary>\r\n    Returns a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> that has the contents of this text including and after the start position.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetSubText(System.Int32)\">\r\n    <summary>\r\n    Returns a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> that has the contents of this text including and after the start position.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool ContentEquals(SourceText other)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ContentEquals(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Compares the content with content of another <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.ContentEquals(Microsoft.CodeAnalysis.Text.SourceText)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ContentEquals(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Compares the content with content of another <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual IReadOnlyList<TextChangeRange> GetChangeRanges(SourceText oldText)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Gets the set of <see cref=\"T:Microsoft.CodeAnalysis.Text.TextChangeRange\"/> that describe how the text changed\r\n    between this text an older version. This may be multiple detailed changes\r\n    or a single change encompassing the entire text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.GetChangeRanges(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Gets the set of <see cref=\"T:Microsoft.CodeAnalysis.Text.TextChangeRange\"/> that describe how the text changed\r\n    between this text an older version. This may be multiple detailed changes\r\n    or a single change encompassing the entire text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual SourceText WithChanges(IEnumerable<TextChange> changes)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})\">\r\n    <summary>\r\n    Constructs a new SourceText from this text with the specified changes.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(IEnumerable{Microsoft.CodeAnalysis.Text.TextChange})\">\r\n    <summary>\r\n    Constructs a new SourceText from this text with the specified changes.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SourceText Replace(int start, int length, string newText)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)\">\r\n    <summary>\r\n    Returns a new SourceText with the specified range of characters replaced by the new text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Replace(System.Int32,System.Int32,System.String)\">\r\n    <summary>\r\n    Returns a new SourceText with the specified range of characters replaced by the new text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual string ToString(TextSpan span)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a string containing the characters in specified span.\r\n    </summary>\r\n    <exception cref=\"T:ArgumentOutOfRangeException\">When given span is outside of the text range.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ToString(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a string containing the characters in specified span.\r\n    </summary>\r\n    <exception cref=\"T:ArgumentOutOfRangeException\">When given span is outside of the text range.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SourceText WithChanges(params TextChange[] changes)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(Microsoft.CodeAnalysis.Text.TextChange[])\">\r\n    <summary>\r\n    Constructs a new SourceText from this text with the specified changes.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(Microsoft.CodeAnalysis.Text.TextChange[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.WithChanges(Microsoft.CodeAnalysis.Text.TextChange[])\">\r\n    <summary>\r\n    Constructs a new SourceText from this text with the specified changes.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ToString\">\r\n    <summary>\r\n    Provides a string representation of the SourceText.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.ToString",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.ToString\">\r\n    <summary>\r\n    Provides a string representation of the SourceText.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static SourceText From(Stream stream, Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.From(Stream,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Constructs a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> from stream content.\r\n    </summary>\r\n    <param name=\"stream\">Stream.</param>\r\n    <param name=\"encoding\">\r\n    Data encoding to use if the stream doesn't start with Byte Order Mark specifying the encoding.\r\n    <see cref=\"!:Encoding.UTF8\"/> if not specified.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"stream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">\r\n    <paramref name=\"stream\"/> doesn't support reading or seeking.\r\n    <paramref name=\"checksumAlgorithm\"/> is not supported.\r\n    </exception>\r\n    <exception cref=\"!:IOException\">An I/O error occurs.</exception>\r\n    <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.From(Stream,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.From(Stream,Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Constructs a <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> from stream content.\r\n    </summary>\r\n    <param name=\"stream\">Stream.</param>\r\n    <param name=\"encoding\">\r\n    Data encoding to use if the stream doesn't start with Byte Order Mark specifying the encoding.\r\n    <see cref=\"!:Encoding.UTF8\"/> if not specified.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"stream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">\r\n    <paramref name=\"stream\"/> doesn't support reading or seeking.\r\n    <paramref name=\"checksumAlgorithm\"/> is not supported.\r\n    </exception>\r\n    <exception cref=\"!:IOException\">An I/O error occurs.</exception>\r\n    <remarks>Reads from the beginning of the stream. Leaves the stream open.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SourceText Replace(TextSpan span, string newText)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan,System.String)\">\r\n    <summary>\r\n    Returns a new SourceText with the specified span of characters replaced by the new text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.Replace(Microsoft.CodeAnalysis.Text.TextSpan,System.String)\">\r\n    <summary>\r\n    Returns a new SourceText with the specified span of characters replaced by the new text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)\">\r\n    <summary>\r\n    Copy a range of characters from this SourceText to a destination array.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.SourceText.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)\">\r\n    <summary>\r\n    Copy a range of characters from this SourceText to a destination array.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SourceText",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.SourceText\">\r\n    <summary>\r\n    An abstraction of source text.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Text.SourceText",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.SourceText\">\r\n    <summary>\r\n    An abstraction of source text.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public TextSpan GetTextSpan(LinePositionSpan span)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePositionSpan\"/> to <see cref=\"T:Microsoft.CodeAnalysis.Text.TextSpan\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetTextSpan(Microsoft.CodeAnalysis.Text.LinePositionSpan)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePositionSpan\"/> to <see cref=\"T:Microsoft.CodeAnalysis.Text.TextSpan\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public LinePositionSpan GetLinePositionSpan(TextSpan span)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.TextSpan\"/> to a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePositionSpan\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePositionSpan(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.TextSpan\"/> to a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePositionSpan\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual LinePosition GetLinePosition(int position)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePosition\"/> corresponding to a character position.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLinePosition(System.Int32)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePosition\"/> corresponding to a character position.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract int IndexOf(int position);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)\">\r\n    <summary>\r\n    The index of the TextLine that encompasses the character position.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.IndexOf(System.Int32)\">\r\n    <summary>\r\n    The index of the TextLine that encompasses the character position.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Enumerator GetEnumerator()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetEnumerator",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public int GetPosition(LinePosition position)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePosition\"/> to a position.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetPosition(Microsoft.CodeAnalysis.Text.LinePosition)\">\r\n    <summary>\r\n    Convert a <see cref=\"T:Microsoft.CodeAnalysis.Text.LinePosition\"/> to a position.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual TextLine GetLineFromPosition(int position)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.TextLine\"/> that encompasses the character position.\r\n    </summary>\r\n    <param name=\"position\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Text.TextLineCollection.GetLineFromPosition(System.Int32)\">\r\n    <summary>\r\n    Gets a <see cref=\"T:Microsoft.CodeAnalysis.Text.TextLine\"/> that encompasses the character position.\r\n    </summary>\r\n    <param name=\"position\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class TextLineCollection",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.TextLineCollection\">\r\n    <summary>\r\n    Abstract base class for <see cref=\"T:Microsoft.CodeAnalysis.Text.TextLine\"/> collections.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Text.TextLineCollection",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.TextLineCollection\">\r\n    <summary>\r\n    Abstract base class for <see cref=\"T:Microsoft.CodeAnalysis.Text.TextLine\"/> collections.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class SourceTextContainer",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.SourceTextContainer\">\r\n    <summary>\r\n    An object that contains an instance of an SourceText and raises events when its current instance\r\n    changes.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Text.SourceTextContainer",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Text.SourceTextContainer\">\r\n    <summary>\r\n    An object that contains an instance of an SourceText and raises events when its current instance\r\n    changes.\r\n    </summary>\r\n</member>\r\n"
        }
      ],
      "Id": "N:Microsoft.CodeAnalysis.Text",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Roslyn.Utilities",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.CodeGen",
      "XmlDocumentation": ""
    },
    {
      "Classes": [
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract SyntaxNode GetSyntax(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntax(CancellationToken)\">\r\n    <summary>\r\n    Retrieves the original referenced syntax node.  \r\n    This action may cause a parse to happen to recover the syntax node.\r\n    </summary>\r\n    <returns>The original referenced syntax node.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntax(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntax(CancellationToken)\">\r\n    <summary>\r\n    Retrieves the original referenced syntax node.  \r\n    This action may cause a parse to happen to recover the syntax node.\r\n    </summary>\r\n    <returns>The original referenced syntax node.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual Task<SyntaxNode> GetSyntaxAsync(CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntaxAsync(CancellationToken)\">\r\n    <summary>\r\n    Retrieves the original referenced syntax node.  \r\n    This action may cause a parse to happen to recover the syntax node.\r\n    </summary>\r\n    <returns>The original referenced syntax node.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntaxAsync(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxReference.GetSyntaxAsync(CancellationToken)\">\r\n    <summary>\r\n    Retrieves the original referenced syntax node.  \r\n    This action may cause a parse to happen to recover the syntax node.\r\n    </summary>\r\n    <returns>The original referenced syntax node.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SyntaxReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxReference\">\r\n    <summary>\r\n    A reference to a syntax node.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxReference\">\r\n    <summary>\r\n    A reference to a syntax node.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)\">\r\n    <summary>\r\n    Creates a new options instance with the specified general diagnostic option.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithGeneralDiagnosticOption(Microsoft.CodeAnalysis.ReportDiagnostic)\">\r\n    <summary>\r\n    Creates a new options instance with the specified general diagnostic option.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object obj);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})\">\r\n    <summary>\r\n    Creates a new options instance with the specified diagnostic-specific options.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})\">\r\n    <summary>\r\n    Creates a new options instance with the specified diagnostic-specific options.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithMetadataReferenceProvider(MetadataReferenceProvider provider);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithMetadataReferenceProvider(Microsoft.CodeAnalysis.MetadataReferenceProvider)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithOutputKind(OutputKind kind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)\">\r\n    <summary>\r\n    Creates a new options instance with the specified output kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithOutputKind(Microsoft.CodeAnalysis.OutputKind)\">\r\n    <summary>\r\n    Creates a new options instance with the specified output kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithMetadataReferenceResolver(Microsoft.CodeAnalysis.MetadataReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithOutputKind(OutputKind kind);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithOutputKind(Microsoft.CodeAnalysis.OutputKind)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> specificDiagnosticOptions);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithSpecificDiagnosticOptions(IEnumerable{Roslyn.Utilities.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected bool EqualsHelper(CompilationOptions other)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.EqualsHelper(Microsoft.CodeAnalysis.CompilationOptions)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithAssemblyIdentityComparer(Microsoft.CodeAnalysis.AssemblyIdentityComparer)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithPlatform(Platform platform)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)\">\r\n    <summary>\r\n    Creates a new options instance with the specified platform.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithPlatform(Microsoft.CodeAnalysis.Platform)\">\r\n    <summary>\r\n    Creates a new options instance with the specified platform.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithOptimizationLevel(OptimizationLevel value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)\">\r\n    <summary>\r\n    Creates a new options instance with optimizations enabled or disabled.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)\">\r\n    <summary>\r\n    Creates a new options instance with optimizations enabled or disabled.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary<string, ReportDiagnostic> specificDiagnosticOptions);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithSpecificDiagnosticOptions(ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithOptimizationLevel(Microsoft.CodeAnalysis.OptimizationLevel)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected int GetHashCodeHelper()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.GetHashCodeHelper",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithMetadataReferenceProvider(MetadataReferenceProvider provider)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithMetadataReferenceProvider(Microsoft.CodeAnalysis.MetadataReferenceProvider)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithFeatures(ImmutableArray<string> features);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithFeatures(ImmutableArray{System.String})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithXmlReferenceResolver(Microsoft.CodeAnalysis.XmlReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithSourceReferenceResolver(Microsoft.CodeAnalysis.SourceReferenceResolver)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable<KeyValuePair<string, ReportDiagnostic>> value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(IEnumerable{Roslyn.Utilities.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})\">\r\n    <summary>\r\n    Creates a new options instance with the specified diagnostic-specific options.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(IEnumerable{Roslyn.Utilities.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationOptions.WithSpecificDiagnosticOptions(IEnumerable{Roslyn.Utilities.KeyValuePair{System.String,Microsoft.CodeAnalysis.ReportDiagnostic}})\">\r\n    <summary>\r\n    Creates a new options instance with the specified diagnostic-specific options.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public CompilationOptions WithStrongNameProvider(StrongNameProvider provider)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.WithStrongNameProvider(Microsoft.CodeAnalysis.StrongNameProvider)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract CompilationOptions CommonWithPlatform(Platform platform);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationOptions.CommonWithPlatform(Microsoft.CodeAnalysis.Platform)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class CompilationOptions",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CompilationOptions\">\r\n    <summary>\r\n    Represents compilation options common to C# and VB.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.CompilationOptions",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CompilationOptions\">\r\n    <summary>\r\n    Represents compilation options common to C# and VB.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class ControlFlowAnalysis",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ControlFlowAnalysis\">\r\n    <summary>\r\n    Provides information about statements which transfer control in and out of a region. This\r\n    information is returned from a call to <see cref=\"M:SemanticModel.AnalyzeControlFlow\" />.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.ControlFlowAnalysis",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ControlFlowAnalysis\">\r\n    <summary>\r\n    Provides information about statements which transfer control in and out of a region. This\r\n    information is returned from a call to <see cref=\"M:SemanticModel.AnalyzeControlFlow\" />.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract void Dispose();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Metadata.Dispose\">\r\n    <summary>\r\n    Releases any resources associated with this instance.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Metadata.Dispose",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Metadata.Dispose\">\r\n    <summary>\r\n    Releases any resources associated with this instance.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Metadata CommonCopy();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Metadata.CommonCopy",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Metadata Copy()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Metadata.Copy\">\r\n    <summary>\r\n    Creates a copy of this object.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Metadata.Copy",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Metadata.Copy\">\r\n    <summary>\r\n    Creates a copy of this object.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class Metadata",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Metadata\">\r\n    <summary>\r\n    Represents immutable assembly or module CLI metadata.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Metadata",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Metadata\">\r\n    <summary>\r\n    Represents immutable assembly or module CLI metadata.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class UnresolvedMetadataReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.UnresolvedMetadataReference\">\r\n    <summary>\r\n    Represents a metadata reference that can't be resolved.\r\n    </summary>\r\n    <remarks>\r\n    For error reporting only, can't be used to reference a metadata file.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.UnresolvedMetadataReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.UnresolvedMetadataReference\">\r\n    <summary>\r\n    Represents a metadata reference that can't be resolved.\r\n    </summary>\r\n    <remarks>\r\n    For error reporting only, can't be used to reference a metadata file.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract Stream OpenRead(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AdditionalStream.OpenRead(CancellationToken)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AdditionalStream.OpenRead(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AdditionalStream.OpenRead(CancellationToken)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class AdditionalStream",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AdditionalStream\">\r\n    <summary>\r\n    Represents a stream of non source code text.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.AdditionalStream",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AdditionalStream\">\r\n    <summary>\r\n    Represents a stream of non source code text.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public virtual void Visit(SyntaxNode node)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Called when the walker visits a node.  This method may be overridden if subclasses want\r\n    to handle the node.  Overrides should call back into this base method if they want the\r\n    children of this node to be visited.\r\n    </summary>\r\n    <param name=\"node\">The current node that the walker is visiting.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.Visit(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Called when the walker visits a node.  This method may be overridden if subclasses want\r\n    to handle the node.  Overrides should call back into this base method if they want the\r\n    children of this node to be visited.\r\n    </summary>\r\n    <param name=\"node\">The current node that the walker is visiting.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected virtual void VisitToken(SyntaxToken token)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Called when the walker visits a token.  This method may be overridden if subclasses want\r\n    to handle the token.  Overrides should call back into this base method if they want the \r\n    trivia of this token to be visited.\r\n    </summary>\r\n    <param name=\"token\">The current token that the walker is visiting.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.VisitToken(Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Called when the walker visits a token.  This method may be overridden if subclasses want\r\n    to handle the token.  Overrides should call back into this base method if they want the \r\n    trivia of this token to be visited.\r\n    </summary>\r\n    <param name=\"token\">The current token that the walker is visiting.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected virtual void VisitTrivia(SyntaxTrivia trivia)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Called when the walker visits a trivia syntax.  This method may be overridden if\r\n    subclasses want to handle the token.  Overrides should call back into this base method if\r\n    they want the children of this trivia syntax to be visited.\r\n    </summary>\r\n    <param name=\"trivia\">The current trivia syntax that the walker is visiting.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxWalker.VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxWalker.VisitTrivia(Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Called when the walker visits a trivia syntax.  This method may be overridden if\r\n    subclasses want to handle the token.  Overrides should call back into this base method if\r\n    they want the children of this trivia syntax to be visited.\r\n    </summary>\r\n    <param name=\"trivia\">The current trivia syntax that the walker is visiting.</param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SyntaxWalker",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxWalker\">\r\n    <summary>\r\n    Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The\r\n    walker will perform a depth first walk of the tree.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxWalker",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxWalker\">\r\n    <summary>\r\n    Walks the syntax tree, allowing subclasses to operate on all nodes, token and trivia.  The\r\n    walker will perform a depth first walk of the tree.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static IMethodSymbol GetConstructedReducedFrom(this IMethodSymbol method)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)\">\r\n    <summary>\r\n    Returns the constructed form of the ReducedFrom property,\r\n    including the type arguments that were either inferred during reduction or supplied at the call site.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ISymbolExtensions.GetConstructedReducedFrom(Microsoft.CodeAnalysis.IMethodSymbol)\">\r\n    <summary>\r\n    Returns the constructed form of the ReducedFrom property,\r\n    including the type arguments that were either inferred during reduction or supplied at the call site.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static class ISymbolExtensions",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.ISymbolExtensions",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> WhereAsArray<T>(this ImmutableArray<T> array, Func<T, bool> predicate)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(ImmutableArray{``0},Func{``0,System.Boolean})\">\r\n    <summary>\r\n    Creates a new immutable array based on filtered elements by the predicate. The array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\">The array to process</param>\r\n    <param name=\"predicate\">The delegate that defines the conditions of the element to search for.</param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(ImmutableArray{``0},Func{``0,System.Boolean})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(ImmutableArray{``0},Func{``0,System.Boolean})\">\r\n    <summary>\r\n    Creates a new immutable array based on filtered elements by the predicate. The array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\">The array to process</param>\r\n    <param name=\"predicate\">The delegate that defines the conditions of the element to search for.</param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<TResult> SelectAsArray<TItem, TArg, TResult>(this ImmutableArray<TItem> items, Func<TItem, int, TArg, TResult> map, TArg arg)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,System.Int32,``1,``2},``1)\">\r\n    <summary>\r\n     Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TArg\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The sequence to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <param name=\"arg\">The extra input used by mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,System.Int32,``1,``2},``1)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,System.Int32,``1,``2},``1)\">\r\n    <summary>\r\n     Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TArg\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The sequence to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <param name=\"arg\">The extra input used by mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutableOrEmpty<T>(this T[] items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])\">\r\n    <summary>\r\n    Converts an array to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns>If the array is null, this will return an empty immutable array.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])\">\r\n    <summary>\r\n    Converts an array to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns>If the array is null, this will return an empty immutable array.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutableOrEmpty<T>(this IEnumerable<T> items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <remarks>If the sequence is null, this will return an empty array.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(IEnumerable{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <remarks>If the sequence is null, this will return an empty array.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<TResult> SelectAsArray<TItem, TResult>(this ImmutableArray<TItem> items, Func<TItem, TResult> map)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(ImmutableArray{``0},Func{``0,``1})\">\r\n    <summary>\r\n    Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The array to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(ImmutableArray{``0},Func{``0,``1})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(ImmutableArray{``0},Func{``0,``1})\">\r\n    <summary>\r\n    Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The array to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool SetEquals<T>(this ImmutableArray<T> array1, ImmutableArray<T> array2, IEqualityComparer<T> comparer)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(ImmutableArray{``0},ImmutableArray{``0},IEqualityComparer{``0})\">\r\n    <summary>\r\n    Determines whether this instance and another immutable array are equal.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array1\"></param>\r\n    <param name=\"array2\"></param>\r\n    <param name=\"comparer\">The comparer to determine if the two arrays are equal.</param>\r\n    <returns>True if the two arrays are equal</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(ImmutableArray{``0},ImmutableArray{``0},IEqualityComparer{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(ImmutableArray{``0},ImmutableArray{``0},IEqualityComparer{``0})\">\r\n    <summary>\r\n    Determines whether this instance and another immutable array are equal.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array1\"></param>\r\n    <param name=\"array2\"></param>\r\n    <param name=\"comparer\">The comparer to determine if the two arrays are equal.</param>\r\n    <returns>True if the two arrays are equal</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutableOrNull<T>(this T[] items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])\">\r\n    <summary>\r\n    Converts a array to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns></returns>\r\n    <remarks>If the sequence is null, this will return the default (null) array.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])\">\r\n    <summary>\r\n    Converts a array to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns></returns>\r\n    <remarks>If the sequence is null, this will return the default (null) array.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "[MethodImpl(MethodImplOptions.AggressiveInlining)]\r\npublic static ImmutableArray<TBase> Cast<TDerived, TBase>(this ImmutableArray<TDerived> items)where TDerived : class, TBase",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(ImmutableArray{``0})\">\r\n    <summary>\r\n    Casts the immutable array of a Type to an immutable array of its base type.\r\n    </summary>\r\n    <typeparam name=\"TDerived\"></typeparam>\r\n    <typeparam name=\"TBase\"></typeparam>\r\n    <param name=\"items\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(ImmutableArray{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(ImmutableArray{``0})\">\r\n    <summary>\r\n    Casts the immutable array of a Type to an immutable array of its base type.\r\n    </summary>\r\n    <typeparam name=\"TDerived\"></typeparam>\r\n    <typeparam name=\"TBase\"></typeparam>\r\n    <param name=\"items\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<TResult> SelectAsArray<TItem, TArg, TResult>(this ImmutableArray<TItem> items, Func<TItem, TArg, TResult> map, TArg arg)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,``1,``2},``1)\">\r\n    <summary>\r\n    Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TArg\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The sequence to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <param name=\"arg\">The extra input used by mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,``1,``2},``1)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(ImmutableArray{``0},Func{``0,``1,``2},``1)\">\r\n    <summary>\r\n    Maps an immutable array to another immutable array.\r\n    </summary>\r\n    <typeparam name=\"TItem\"></typeparam>\r\n    <typeparam name=\"TArg\"></typeparam>\r\n    <typeparam name=\"TResult\"></typeparam>\r\n    <param name=\"items\">The sequence to map</param>\r\n    <param name=\"map\">The mapping delegate</param>\r\n    <param name=\"arg\">The extra input used by mapping delegate</param>\r\n    <returns>If the items's length is 0, this will return an empty immutable array.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutable<T>(this T[] items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])\">\r\n    <summary>\r\n    Converts an array to an immutable array. The array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])\">\r\n    <summary>\r\n    Converts an array to an immutable array. The array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"items\">The sequence to convert</param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static void AddRange<T, U>(this List<T> list, ImmutableArray<U> items)where U : T",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AddRange``2(List{``0},ImmutableArray{``1})\">\r\n    <summary>\r\n    Adds all elements of the immutable array into the list; The list must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <typeparam name=\"U\"></typeparam>\r\n    <param name=\"list\"></param>\r\n    <param name=\"items\"></param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AddRange``2(List{``0},ImmutableArray{``1})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AddRange``2(List{``0},ImmutableArray{``1})\">\r\n    <summary>\r\n    Adds all elements of the immutable array into the list; The list must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <typeparam name=\"U\"></typeparam>\r\n    <param name=\"list\"></param>\r\n    <param name=\"items\"></param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutableOrNull<T>(this IEnumerable<T> items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <remarks>If the sequence is null, this will return the default (null) array.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(IEnumerable{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <remarks>If the sequence is null, this will return the default (null) array.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> NullToEmpty<T>(this ImmutableArray<T> array)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(ImmutableArray{``0})\">\r\n    <summary>\r\n    Returns an empty array if the input array is null (defaut)\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(ImmutableArray{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(ImmutableArray{``0})\">\r\n    <summary>\r\n    Returns an empty array if the input array is null (defaut)\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> AsImmutable<T>(this IEnumerable<T> items)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <exception cref=\"!:ArgumentNullException\">If items is null (default)</exception>\r\n    <remarks>If the sequence is null, this will throw <see cref=\"!:ArgumentNullException\"/></remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(IEnumerable{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(IEnumerable{``0})\">\r\n    <summary>\r\n    Converts a sequence to an immutable array.\r\n    </summary>\r\n    <typeparam name=\"T\">Elemental type of the sequence.</typeparam>\r\n    <param name=\"items\">The sequence to convert.</param>\r\n    <returns>An immutable copy of the contents of the sequence.</returns>\r\n    <exception cref=\"!:ArgumentNullException\">If items is null (default)</exception>\r\n    <remarks>If the sequence is null, this will throw <see cref=\"!:ArgumentNullException\"/></remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<byte> ToImmutable(this MemoryStream stream)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(MemoryStream)\">\r\n    <summary>\r\n    Reads bytes from specified <see cref=\"!:MemoryStream\"/>.\r\n    </summary>\r\n    <param name=\"stream\">The stream.</param>\r\n    <returns>Read-only content of the stream.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(MemoryStream)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(MemoryStream)\">\r\n    <summary>\r\n    Reads bytes from specified <see cref=\"!:MemoryStream\"/>.\r\n    </summary>\r\n    <param name=\"stream\">The stream.</param>\r\n    <returns>Read-only content of the stream.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<T> Distinct<T>(this ImmutableArray<T> array, IEqualityComparer<T> comparer = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(ImmutableArray{``0},IEqualityComparer{``0})\">\r\n    <summary>\r\n    Returns an array of distinct elements, preserving the order in the original array.\r\n    If the array has no duplicates, the original array is returned. The original array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\"></param>\r\n    <param name=\"comparer\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(ImmutableArray{``0},IEqualityComparer{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(ImmutableArray{``0},IEqualityComparer{``0})\">\r\n    <summary>\r\n    Returns an array of distinct elements, preserving the order in the original array.\r\n    If the array has no duplicates, the original array is returned. The original array must not be null.\r\n    </summary>\r\n    <typeparam name=\"T\"></typeparam>\r\n    <param name=\"array\"></param>\r\n    <param name=\"comparer\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static partial class ImmutableArrayExtensions",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ImmutableArrayExtensions\">\r\n    <summary>\r\n    The collection of extension methods for the <see cref=\"!:ImmutableArray&lt;T&gt;\"/> type\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.ImmutableArrayExtensions",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ImmutableArrayExtensions\">\r\n    <summary>\r\n    The collection of extension methods for the <see cref=\"!:ImmutableArray&lt;T&gt;\"/> type\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.ToString",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object obj);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable<Location> additionalLocations, params object[] messageArgs)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},System.Object[])\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"descriptor\">A <see cref=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\"/> describing the diagnostic</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"additionalLocations\">\r\n    An optional set of additional locations related to the diagnostic.\r\n    Typically, these are locations of other items referenced in the message.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations\"/> will return an empty list.\r\n    </param>\r\n    <param name=\"messageArgs\">Arguments to the message of the diagnostic</param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n    <remarks>\r\n    If severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel\"/> will be 1; otherwise 0.\r\n    <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError\"/> will be false.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},System.Object[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},System.Object[])\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"descriptor\">A <see cref=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\"/> describing the diagnostic</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"additionalLocations\">\r\n    An optional set of additional locations related to the diagnostic.\r\n    Typically, these are locations of other items referenced in the message.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations\"/> will return an empty list.\r\n    </param>\r\n    <param name=\"messageArgs\">Arguments to the message of the diagnostic</param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n    <remarks>\r\n    If severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel\"/> will be 1; otherwise 0.\r\n    <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError\"/> will be false.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static Diagnostic Create(string id, string category, string message, DiagnosticSeverity severity, bool isEnabledByDefault, int warningLevel, bool isWarningAsError, string description = null, string helpLink = null, Location location = null, IEnumerable<Location> additionalLocations = null, IEnumerable<string> customTags = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,System.String,System.String,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},IEnumerable{System.String})\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"id\">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as \"CS1001\".</param>\r\n    <param name=\"category\">The category of the diagnostic. For diagnostics generated by the compiler, the category will be \"Compiler\".</param>\r\n    <param name=\"message\">The diagnostic message text.</param>\r\n    <param name=\"severity\">The diagnostic severity.</param>\r\n    <param name=\"isEnabledByDefault\">True if the diagnostic is enabled by default</param>\r\n    <param name=\"warningLevel\">The warning level, between 1 and 4 if severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>; otherwise 0.</param>\r\n    <param name=\"isWarningAsError\">True if the diagnostic is a warning and should be treated as an error; otherwise false.</param>\r\n    <param name=\"description\">An optional longer description for the diagnostic.</param>\r\n    <param name=\"helpLink\">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"additionalLocations\">\r\n    An optional set of additional locations related to the diagnostic.\r\n    Typically, these are locations of other items referenced in the message.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations\"/> will return an empty list.\r\n    </param>\r\n    <param name=\"customTags\">\r\n    An optional set of custom tags for the diagnostic. See <see cref=\"T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags\"/> for some well known tags.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.CustomTags\"/> will return an empty list.\r\n    </param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,System.String,System.String,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(System.String,System.String,System.String,Microsoft.CodeAnalysis.DiagnosticSeverity,System.Boolean,System.Int32,System.Boolean,System.String,System.String,Microsoft.CodeAnalysis.Location,IEnumerable{Microsoft.CodeAnalysis.Location},IEnumerable{System.String})\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"id\">An identifier for the diagnostic. For diagnostics generated by the compiler, this will be a numeric code with a prefix such as \"CS1001\".</param>\r\n    <param name=\"category\">The category of the diagnostic. For diagnostics generated by the compiler, the category will be \"Compiler\".</param>\r\n    <param name=\"message\">The diagnostic message text.</param>\r\n    <param name=\"severity\">The diagnostic severity.</param>\r\n    <param name=\"isEnabledByDefault\">True if the diagnostic is enabled by default</param>\r\n    <param name=\"warningLevel\">The warning level, between 1 and 4 if severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>; otherwise 0.</param>\r\n    <param name=\"isWarningAsError\">True if the diagnostic is a warning and should be treated as an error; otherwise false.</param>\r\n    <param name=\"description\">An optional longer description for the diagnostic.</param>\r\n    <param name=\"helpLink\">An optional hyperlink that provides more detailed information regarding the diagnostic.</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"additionalLocations\">\r\n    An optional set of additional locations related to the diagnostic.\r\n    Typically, these are locations of other items referenced in the message.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.AdditionalLocations\"/> will return an empty list.\r\n    </param>\r\n    <param name=\"customTags\">\r\n    An optional set of custom tags for the diagnostic. See <see cref=\"T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags\"/> for some well known tags.\r\n    If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.CustomTags\"/> will return an empty list.\r\n    </param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract string GetMessage(CultureInfo culture = null);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.GetMessage(CultureInfo)\">\r\n    <summary>\r\n    Get the text of the message.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.GetMessage(CultureInfo)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.GetMessage(CultureInfo)\">\r\n    <summary>\r\n    Get the text of the message.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, params object[] messageArgs)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Object[])\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"descriptor\">A <see cref=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\"/> describing the diagnostic</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"messageArgs\">Arguments to the message of the diagnostic</param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n    <remarks>\r\n    If severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel\"/> will be 1; otherwise 0.\r\n    <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError\"/> will be false.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Object[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostic.Create(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.Location,System.Object[])\">\r\n    <summary>\r\n    Creates a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.\r\n    </summary>\r\n    <param name=\"descriptor\">A <see cref=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\"/> describing the diagnostic</param>\r\n    <param name=\"location\">An optional primary location of the diagnostic. If null, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.Location\"/> will return <see cref=\"P:Microsoft.CodeAnalysis.Location.None\"/>.</param>\r\n    <param name=\"messageArgs\">Arguments to the message of the diagnostic</param>\r\n    <returns>The <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> instance.</returns>\r\n    <remarks>\r\n    If severity is <see cref=\"F:Microsoft.CodeAnalysis.DiagnosticSeverity.Warning\"/>, <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.WarningLevel\"/> will be 1; otherwise 0.\r\n    <see cref=\"P:Microsoft.CodeAnalysis.Diagnostic.IsWarningAsError\"/> will be false.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract bool Equals(Diagnostic obj);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostic.Equals(Microsoft.CodeAnalysis.Diagnostic)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract partial class Diagnostic",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostic\">\r\n    <summary>\r\n    Represents a diagnostic, such as a compiler error or a warning, along with the location where it occurred.\r\n    </summary>\r\n    <summary>\r\n    A diagnostic (such as a compiler error or a warning), along with the location where it occurred.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostic",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostic\">\r\n    <summary>\r\n    Represents a diagnostic, such as a compiler error or a warning, along with the location where it occurred.\r\n    </summary>\r\n    <summary>\r\n    A diagnostic (such as a compiler error or a warning), along with the location where it occurred.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public ImmutableArray<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container = null, string name = null, bool includeReducedExtensionMethods = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\">\r\n    <summary>\r\n    Gets the available named symbols in the context of the specified location and optional container. Only\r\n    symbols that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <param name=\"includeReducedExtensionMethods\">Consider (reduced) extension methods.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Labels are not considered (see <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\"/>).\r\n    \r\n    Non-reduced extension methods are considered regardless of the value of <paramref name=\"includeReducedExtensionMethods\"/>.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\">\r\n    <summary>\r\n    Gets the available named symbols in the context of the specified location and optional container. Only\r\n    symbols that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <param name=\"includeReducedExtensionMethods\">Consider (reduced) extension methods.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Labels are not considered (see <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\"/>).\r\n    \r\n    Non-reduced extension methods are considered regardless of the value of <paramref name=\"includeReducedExtensionMethods\"/>.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeTypeInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets symbol information about a syntax node.\r\n    </summary>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets symbol information about a syntax node.\r\n    </summary>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets type information about a syntax node.\r\n    </summary>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetTypeInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets type information about a syntax node.\r\n    </summary>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool IsAccessibleCore(int position, ISymbol symbol);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)\">\r\n    <summary>\r\n    Determines if the symbol is accessible from the specified location. \r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"symbol\">The symbol that we are checking to see if it accessible.</param>\r\n    <returns>\r\n    True if \"symbol is accessible, false otherwise.</returns>\r\n    <remarks>\r\n    This method only checks accessibility from the point of view of the accessibility\r\n    modifiers on symbol and its containing types. Even if true is returned, the given symbol\r\n    may not be able to be referenced for other reasons, such as name hiding.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsAccessibleCore(System.Int32,Microsoft.CodeAnalysis.ISymbol)\">\r\n    <summary>\r\n    Determines if the symbol is accessible from the specified location. \r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"symbol\">The symbol that we are checking to see if it accessible.</param>\r\n    <returns>\r\n    True if \"symbol is accessible, false otherwise.</returns>\r\n    <remarks>\r\n    This method only checks accessibility from the point of view of the accessibility\r\n    modifiers on symbol and its containing types. Even if true is returned, the given symbol\r\n    may not be able to be referenced for other reasons, such as name hiding.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If \"nameSyntax\" resolves to an alias name, return the IAliasSymbol corresponding\r\n    to A. Otherwise return null.\r\n    </summary>\r\n    <param name=\"nameSyntax\">Name to get alias info for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the alias information.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetAliasInfoCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If \"nameSyntax\" resolves to an alias name, return the IAliasSymbol corresponding\r\n    to A. Otherwise return null.\r\n    </summary>\r\n    <param name=\"nameSyntax\">Name to get alias info for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the alias information.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> LookupLabelsCore(int position, string name);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabelsCore(System.Int32,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the method body and initializer errors within the syntax tree associated with this\r\n    object. Does not get errors involving incorrect syntax or declarations.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>The method body errors for a syntax tree are not cached. The first time this method\r\n    is called, all method bodies are analyzed for diagnostics. Calling this a second time\r\n    will repeat this work.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetMethodBodyDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the method body and initializer errors within the syntax tree associated with this\r\n    object. Does not get errors involving incorrect syntax or declarations.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>The method body errors for a syntax tree are not cached. The first time this method\r\n    is called, all method bodies are analyzed for diagnostics. Calling this a second time\r\n    will repeat this work.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<DeclarationInfo> GetDeclarationsInSpan(TextSpan span, bool getSymbol, CancellationToken cancellationToken);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationsInSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,CancellationToken)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.DeclarationInfo\"/> for all the declarations whose span overlaps with the given <paramref name=\"span\"/>.\r\n    </summary>\r\n    <param name=\"span\">Span to get declarations.</param>\r\n    <param name=\"getSymbol\">Flag indicating whether <see cref=\"P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol\"/> should be computed for the returned declartion infos.\r\n    If false, then <see cref=\"P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol\"/> is always null.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationsInSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationsInSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,CancellationToken)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.DeclarationInfo\"/> for all the declarations whose span overlaps with the given <paramref name=\"span\"/>.\r\n    </summary>\r\n    <param name=\"span\">Span to get declarations.</param>\r\n    <param name=\"getSymbol\">Flag indicating whether <see cref=\"P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol\"/> should be computed for the returned declartion infos.\r\n    If false, then <see cref=\"P:Microsoft.CodeAnalysis.DeclarationInfo.DeclaredSymbol\"/> is always null.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the declaration errors within the syntax tree associated with this\r\n    object. Does not get errors involving incorrect syntax, compiling method bodies or initializers.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>The declaration errors for a syntax tree are cached. The first time this method\r\n    is called, all declarations are analyzed for diagnostics. Calling this a second time\r\n    will return the cached diagnostics.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclarationDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the declaration errors within the syntax tree associated with this\r\n    object. Does not get errors involving incorrect syntax, compiling method bodies or initializers.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>The declaration errors for a syntax tree are cached. The first time this method\r\n    is called, all declarations are analyzed for diagnostics. Calling this a second time\r\n    will return the cached diagnostics.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    If <paramref name=\"nameSyntax\"/> is an identifier name syntax node, return the <see cref=\"T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo\"/> corresponding\r\n    to it.\r\n    </summary>\r\n    <param name=\"nameSyntax\">The nameSyntax node to get semantic information for.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    If <paramref name=\"nameSyntax\"/> is an identifier name syntax node, return the <see cref=\"T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo\"/> corresponding\r\n    to it.\r\n    </summary>\r\n    <param name=\"nameSyntax\">The nameSyntax node to get semantic information for.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all the errors within the syntax tree associated with this object. Includes errors\r\n    involving compiling method bodies or initializers, in addition to the errors returned by\r\n    GetDeclarationDiagnostics.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>\r\n    Because this method must semantically bind all method bodies and initializers to check\r\n    for diagnostics, it may take a significant amount of time. Unlike\r\n    GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not\r\n    cached, any semantic information used to obtain the diagnostics is discarded.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all the errors within the syntax tree associated with this object. Includes errors\r\n    involving compiling method bodies or initializers, in addition to the errors returned by\r\n    GetDeclarationDiagnostics.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n    <remarks>\r\n    Because this method must semantically bind all method bodies and initializers to check\r\n    for diagnostics, it may take a significant amount of time. Unlike\r\n    GetDeclarationDiagnostics, diagnostics for method bodies and initializers are not\r\n    cached, any semantic information used to obtain the diagnostics is discarded.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node.\r\n    </summary>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbol declared by the node or null if the node is not a declaration.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node.\r\n    </summary>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbol declared by the node or null if the node is not a declaration.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetSyntaxDiagnostics(TextSpan? span = null, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the syntax errors within the syntax tree associated with this\r\n    object. Does not get errors involving declarations or compiling method bodies or initializers.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSyntaxDiagnostics(System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan},CancellationToken)\">\r\n    <summary>\r\n    Get all of the syntax errors within the syntax tree associated with this\r\n    object. Does not get errors involving declarations or compiling method bodies or initializers.\r\n    </summary>\r\n    <param name=\"span\">Optional span within the syntax tree for which to get diagnostics.\r\n    If no argument is specified, then diagnostics for the entire tree are returned.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the diagnostics.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "[Obsolete(\"This API will be removed in a subsequent release.\")]\r\npublic CommonOverloadResolutionResult<TSymbol> ResolveOverloads<TSymbol>(int position, ImmutableArray<TSymbol> members, ImmutableArray<ITypeSymbol> typeArguments, ImmutableArray<SyntaxNode> arguments)where TSymbol : ISymbol",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.ResolveOverloads``1(System.Int32,ImmutableArray{``0},ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Resolves the set of provided arguments against set of provided members to determine the\r\n    appropriate overload. The arguments are bound as if they were at 'position' within this\r\n    semantic model. An CommonOverloadResolutionResult is returned that gives the result of\r\n    the compiler's overload resolution analysis.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel. This position is used when binding the arguments.\r\n    </param>\r\n    <param name=\"members\">The set of members to resolve overloads among.</param>\r\n    <param name=\"arguments\">The list of arguments, in order, to use when resolving the\r\n    overloads. The arguments are interpreted as if they occurred within the declaration\r\n    scope that encloses \"position\".</param>\r\n    <param name=\"typeArguments\">If present, the type argument provided. If not provided,\r\n    type inference is done.</param>\r\n    <remarks>\r\n    This can be used to resolve constructors, properties as well as methods.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.ResolveOverloads``1(System.Int32,ImmutableArray{``0},ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.ResolveOverloads``1(System.Int32,ImmutableArray{``0},ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Resolves the set of provided arguments against set of provided members to determine the\r\n    appropriate overload. The arguments are bound as if they were at 'position' within this\r\n    semantic model. An CommonOverloadResolutionResult is returned that gives the result of\r\n    the compiler's overload resolution analysis.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel. This position is used when binding the arguments.\r\n    </param>\r\n    <param name=\"members\">The set of members to resolve overloads among.</param>\r\n    <param name=\"arguments\">The list of arguments, in order, to use when resolving the\r\n    overloads. The arguments are interpreted as if they occurred within the declaration\r\n    scope that encloses \"position\".</param>\r\n    <param name=\"typeArguments\">If present, the type argument provided. If not provided,\r\n    type inference is done.</param>\r\n    <remarks>\r\n    This can be used to resolve constructors, properties as well as methods.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    When getting information for a symbol that resolves to a method group or property group,\r\n    from which a method is then chosen; the chosen method or property is present in Symbol;\r\n    all methods in the group that was consulted are placed in this property.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetMemberGroupCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    When getting information for a symbol that resolves to a method group or property group,\r\n    from which a method is then chosen; the chosen method or property is present in Symbol;\r\n    all methods in the group that was consulted are placed in this property.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol\r\n    that the position is considered inside of.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbol(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol\r\n    that the position is considered inside of.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"statement\">The statement to be analyzed.</param>\r\n    <returns>An object that can be used to obtain the result of the control flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The statement must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"statement\">The statement to be analyzed.</param>\r\n    <returns>An object that can be used to obtain the result of the control flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The statement must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<ISymbol> LookupLabels(int position, string name = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\">\r\n    <summary>\r\n    Gets the available named label symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupLabels(System.Int32,System.String)\">\r\n    <summary>\r\n    Gets the available named label symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)\">\r\n    <summary>\r\n    Field-like events can be used as fields in types that can access private\r\n    members of the declaring type of the event.\r\n    </summary>\r\n    <remarks>\r\n    Always false for VB events.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsFieldCore(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)\">\r\n    <summary>\r\n    Field-like events can be used as fields in types that can access private\r\n    members of the declaring type of the event.\r\n    </summary>\r\n    <remarks>\r\n    Always false for VB events.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> LookupBaseMembersCore(int position, string name);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembersCore(System.Int32,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol\r\n    that the position is considered inside of.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetEnclosingSymbolCore(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Given a position in the SyntaxTree for this SemanticModel returns the innermost Symbol\r\n    that the position is considered inside of.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"firstStatement\">The first node to be included within the analysis.</param>\r\n    <param name=\"lastStatement\">The last node to be included within the analysis.</param>\r\n    <returns>An object that can be used to obtain the result of the data flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The first and last nodes must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"firstStatement\">The first node to be included within the analysis.</param>\r\n    <param name=\"lastStatement\">The last node to be included within the analysis.</param>\r\n    <returns>An object that can be used to obtain the result of the data flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The first and last nodes must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container = null, string name = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Gets the available named namespace and type symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Does not return INamespaceOrTypeSymbol, because there could be aliases.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Gets the available named namespace and type symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Does not return INamespaceOrTypeSymbol, because there could be aliases.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node. Unlike <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\"/>,\r\n    this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,\r\n    which can declare multiple symbols, this method returns all declared symbols.\r\n    </summary>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbols declared by the node.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolsCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node. Unlike <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.GetDeclaredSymbolForNode(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\"/>,\r\n    this method returns all symbols declared by a given declaration syntax node. Specifically, in the case of field declaration syntax nodes,\r\n    which can declare multiple symbols, this method returns all declared symbols.\r\n    </summary>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbols declared by the node.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container = null, string name = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Gets the available named static member symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    \r\n    Non-reduced extension methods are considered, since they are static methods.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Essentially the same as filtering instance members out of the results of an analogous <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/> call.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Gets the available named static member symbols in the context of the specified location and optional container.\r\n    Only members that are accessible and visible from the given location are returned.\r\n    \r\n    Non-reduced extension methods are considered, since they are static methods.\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"container\">The container to search for symbols within. If null then the enclosing declaration\r\n    scope around position is used.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible. Even if \"container\" is\r\n    specified, the \"position\" location is significant for determining which members of \"containing\" are\r\n    accessible. \r\n    \r\n    Essentially the same as filtering instance members out of the results of an analogous <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/> call.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembersCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"statementOrExpression\">The statement or expression to be analyzed.</param>\r\n    <returns>An object that can be used to obtain the result of the data flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The statement or expression is not with a method\r\n    body or field or property initializer.</exception>\r\n    <remarks>\r\n    The statement or expression must be fully inside a method body.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeDataFlowCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"statementOrExpression\">The statement or expression to be analyzed.</param>\r\n    <returns>An object that can be used to obtain the result of the data flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The statement or expression is not with a method\r\n    body or field or property initializer.</exception>\r\n    <remarks>\r\n    The statement or expression must be fully inside a method body.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Optional<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If the node provided has a constant value an Optional value will be returned with\r\n    HasValue set to true and with Value set to the constant.  If the node does not have an\r\n    constant value, an Optional will be returned with HasValue set to false.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValueCore(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If the node provided has a constant value an Optional value will be returned with\r\n    HasValue set to true and with Value set to the constant.  If the node does not have an\r\n    constant value, an Optional will be returned with HasValue set to false.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypesCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeSymbolInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Optional<object> GetConstantValue(SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If the node provided has a constant value an Optional value will be returned with\r\n    HasValue set to true and with Value set to the constant.  If the node does not have an\r\n    constant value, an Optional will be returned with HasValue set to false.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetConstantValue(Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If the node provided has a constant value an Optional value will be returned with\r\n    HasValue set to true and with Value set to the constant.  If the node does not have an\r\n    constant value, an Optional will be returned with HasValue set to false.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ImmutableArray<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbolsCore(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\">\r\n    <summary>\r\n    Backing implementation of <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<ISymbol> LookupBaseMembers(int position, string name = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)\">\r\n    <summary>\r\n    Gets the available base type members in the context of the specified location.  Akin to\r\n    calling <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/> with the container set to the immediate base type of\r\n    the type in which <paramref name=\"position\"/> occurs.  However, the accessibility rules\r\n    are different: protected members of the base type will be visible.\r\n    \r\n    Consider the following example:\r\n    \r\n      public class Base\r\n      {\r\n          protected void M() { }\r\n      }\r\n      \r\n      public class Derived : Base\r\n      {\r\n          void Test(Base b)\r\n          {\r\n              b.M(); // Error - cannot access protected member.\r\n              base.M();\r\n          }\r\n      }\r\n    \r\n    Protected members of an instance of another type are only accessible if the instance is known\r\n    to be \"this\" instance (as indicated by the \"base\" keyword).\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible.\r\n    \r\n    Non-reduced extension methods are considered, but reduced extension methods are not.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupBaseMembers(System.Int32,System.String)\">\r\n    <summary>\r\n    Gets the available base type members in the context of the specified location.  Akin to\r\n    calling <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)\"/> with the container set to the immediate base type of\r\n    the type in which <paramref name=\"position\"/> occurs.  However, the accessibility rules\r\n    are different: protected members of the base type will be visible.\r\n    \r\n    Consider the following example:\r\n    \r\n      public class Base\r\n      {\r\n          protected void M() { }\r\n      }\r\n      \r\n      public class Derived : Base\r\n      {\r\n          void Test(Base b)\r\n          {\r\n              b.M(); // Error - cannot access protected member.\r\n              base.M();\r\n          }\r\n      }\r\n    \r\n    Protected members of an instance of another type are only accessible if the instance is known\r\n    to be \"this\" instance (as indicated by the \"base\" keyword).\r\n    </summary>\r\n    <param name=\"position\">The character position for determining the enclosing declaration scope and\r\n    accessibility.</param>\r\n    <param name=\"name\">The name of the symbol to find. If null is specified then symbols\r\n    with any names are returned.</param>\r\n    <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>\r\n    <remarks>\r\n    The \"position\" is used to determine what variables are visible and accessible.\r\n    \r\n    Non-reduced extension methods are considered, but reduced extension methods are not.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool IsAccessible(int position, ISymbol symbol)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)\">\r\n    <summary>\r\n    Determines if the symbol is accessible from the specified location. \r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"symbol\">The symbol that we are checking to see if it accessible.</param>\r\n    <returns>\r\n    True if \"symbol is accessible, false otherwise.</returns>\r\n    <remarks>\r\n    This method only checks accessibility from the point of view of the accessibility\r\n    modifiers on symbol and its containing types. Even if true is returned, the given symbol\r\n    may not be able to be referenced for other reasons, such as name hiding.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)\">\r\n    <summary>\r\n    Determines if the symbol is accessible from the specified location. \r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"symbol\">The symbol that we are checking to see if it accessible.</param>\r\n    <returns>\r\n    True if \"symbol is accessible, false otherwise.</returns>\r\n    <remarks>\r\n    This method only checks accessibility from the point of view of the accessibility\r\n    modifiers on symbol and its containing types. Even if true is returned, the given symbol\r\n    may not be able to be referenced for other reasons, such as name hiding.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the name in the context of the specified location and sees if it resolves to an\r\n    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"nameSyntax\">A syntax node that represents a name. This syntax\r\n    node need not and typically does not appear in the source code referred to by the\r\n    SemanticModel instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the name as a full expression,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <remarks>The passed in name is interpreted as a stand-alone name, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetSpeculativeAliasInfoCore(System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the name in the context of the specified location and sees if it resolves to an\r\n    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\r\n    </summary>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"nameSyntax\">A syntax node that represents a name. This syntax\r\n    node need not and typically does not appear in the source code referred to by the\r\n    SemanticModel instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the name as a full expression,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <remarks>The passed in name is interpreted as a stand-alone name, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"firstStatement\">The first node to be included within the analysis.</param>\r\n    <param name=\"lastStatement\">The last node to be included within the analysis.</param>\r\n    <returns>An object that can be used to obtain the result of the control flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The first and last nodes must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeControlFlowCore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n    <param name=\"firstStatement\">The first node to be included within the analysis.</param>\r\n    <param name=\"lastStatement\">The last node to be included within the analysis.</param>\r\n    <returns>An object that can be used to obtain the result of the control flow analysis.</returns>\r\n    <exception cref=\"!:System.ArgumentException\">The span is not with a method\r\n    body.</exception>\r\n    <remarks>\r\n    The first and last nodes must be fully inside the same method body.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    If <paramref name=\"nameSyntax\"/> is an identifier name syntax node, return the <see cref=\"T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo\"/> corresponding\r\n    to it.\r\n    </summary>\r\n    <param name=\"nameSyntax\">The nameSyntax node to get semantic information for.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.GetPreprocessingSymbolInfoCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    If <paramref name=\"nameSyntax\"/> is an identifier name syntax node, return the <see cref=\"T:Microsoft.CodeAnalysis.PreprocessingSymbolInfo\"/> corresponding\r\n    to it.\r\n    </summary>\r\n    <param name=\"nameSyntax\">The nameSyntax node to get semantic information for.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)\">\r\n    <summary>\r\n    Field-like events can be used as fields in types that can access private\r\n    members of the declaring type of the event.\r\n    </summary>\r\n    <remarks>\r\n    Always false for VB events.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)\">\r\n    <summary>\r\n    Field-like events can be used as fields in types that can access private\r\n    members of the declaring type of the event.\r\n    </summary>\r\n    <remarks>\r\n    Always false for VB events.\r\n    </remarks>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SemanticModel",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SemanticModel\">\r\n    <summary>\r\n    Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,\r\n    an instance is obtained by a call to GetBinding on a Compilation or Compilation.\r\n    </summary>\r\n    <remarks>\r\n    <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it\r\n    is much more efficient to use a single instance of SemanticModel when asking multiple\r\n    questions about a syntax tree, because information from the first question may be reused.\r\n    This also means that holding onto an instance of SemanticModel for a long time may keep a\r\n    significant amount of memory from being garbage collected.\r\n    </para>\r\n    <para>\r\n    When an answer is a named symbol that is reachable by traversing from the root of the symbol\r\n    table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned\r\n    (i.e. the returned value will be reference-equal to one reachable from the root of the\r\n    symbol table). Symbols representing entities without names (e.g. array-of-int) may or may\r\n    not exhibit reference equality. However, some named symbols (such as local variables) are\r\n    not reachable from the root. These symbols are visible as answers to semantic questions.\r\n    When the same SemanticModel object is used, the answers exhibit reference-equality.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SemanticModel",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SemanticModel\">\r\n    <summary>\r\n    Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,\r\n    an instance is obtained by a call to GetBinding on a Compilation or Compilation.\r\n    </summary>\r\n    <remarks>\r\n    <para>An instance of SemanticModel caches local symbols and semantic information. Thus, it\r\n    is much more efficient to use a single instance of SemanticModel when asking multiple\r\n    questions about a syntax tree, because information from the first question may be reused.\r\n    This also means that holding onto an instance of SemanticModel for a long time may keep a\r\n    significant amount of memory from being garbage collected.\r\n    </para>\r\n    <para>\r\n    When an answer is a named symbol that is reachable by traversing from the root of the symbol\r\n    table, (that is, from an AssemblySymbol of the Compilation), that symbol will be returned\r\n    (i.e. the returned value will be reference-equal to one reachable from the root of the\r\n    symbol table). Symbols representing entities without names (e.g. array-of-int) may or may\r\n    not exhibit reference equality. However, some named symbols (such as local variables) are\r\n    not reachable from the root. These symbols are visible as answers to semantic questions.\r\n    When the same SemanticModel object is used, the answers exhibit reference-equality.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static void ToLower(StringBuilder builder)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(StringBuilder)\">\r\n    <summary>\r\n    In-place convert string in StringBuilder to lower case in culture invariant way\r\n    </summary>\r\n    <param name=\"builder\"></param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(StringBuilder)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(StringBuilder)\">\r\n    <summary>\r\n    In-place convert string in StringBuilder to lower case in culture invariant way\r\n    </summary>\r\n    <param name=\"builder\"></param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static int GetHashCode(string value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(System.String)\">\r\n    <summary>\r\n    Gets a case-insensitive hash code for VB identifiers.\r\n    </summary>\r\n    <param name=\"value\">identifier to get the hash code for</param>\r\n    <returns>The hash code for the given identifier</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.GetHashCode(System.String)\">\r\n    <summary>\r\n    Gets a case-insensitive hash code for VB identifiers.\r\n    </summary>\r\n    <param name=\"value\">identifier to get the hash code for</param>\r\n    <returns>The hash code for the given identifier</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool Equals(string left, string right)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.String,System.String)\">\r\n    <summary>\r\n    Determines if two VB identifiers are equal according to the VB identifier comparison rules.\r\n    </summary>\r\n    <param name=\"left\">First identifier to compare</param>\r\n    <param name=\"right\">Second identifier to compare</param>\r\n    <returns>true if the identifiers should be considered the same.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Equals(System.String,System.String)\">\r\n    <summary>\r\n    Determines if two VB identifiers are equal according to the VB identifier comparison rules.\r\n    </summary>\r\n    <param name=\"left\">First identifier to compare</param>\r\n    <param name=\"right\">Second identifier to compare</param>\r\n    <returns>true if the identifiers should be considered the same.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool EndsWith(string value, string possibleEnd)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(System.String,System.String)\">\r\n    <summary>\r\n    Determines if the string 'value' end with string 'possibleEnd'.\r\n    </summary>\r\n    <param name=\"value\"></param>\r\n    <param name=\"possibleEnd\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.EndsWith(System.String,System.String)\">\r\n    <summary>\r\n    Determines if the string 'value' end with string 'possibleEnd'.\r\n    </summary>\r\n    <param name=\"value\"></param>\r\n    <param name=\"possibleEnd\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static string ToLower(string value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.String)\">\r\n    <summary>\r\n    Convert a string to lower case in culture invariant way\r\n    </summary>\r\n    <param name=\"value\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.ToLower(System.String)\">\r\n    <summary>\r\n    Convert a string to lower case in culture invariant way\r\n    </summary>\r\n    <param name=\"value\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static int Compare(string left, string right)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.String,System.String)\">\r\n    <summary>\r\n    Compares two VB identifiers according to the VB identifier comparison rules.\r\n    </summary>\r\n    <param name=\"left\">First identifier to compare</param>\r\n    <param name=\"right\">Second identifier to compare</param>\r\n    <returns>-1 if <paramref name=\"left\"/> &lt; <paramref name=\"right\"/>, 1 if <paramref name=\"left\"/> &gt; <paramref name=\"right\"/>, 0 if they are equal.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CaseInsensitiveComparison.Compare(System.String,System.String)\">\r\n    <summary>\r\n    Compares two VB identifiers according to the VB identifier comparison rules.\r\n    </summary>\r\n    <param name=\"left\">First identifier to compare</param>\r\n    <param name=\"right\">Second identifier to compare</param>\r\n    <returns>-1 if <paramref name=\"left\"/> &lt; <paramref name=\"right\"/>, 1 if <paramref name=\"left\"/> &gt; <paramref name=\"right\"/>, 0 if they are equal.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static class CaseInsensitiveComparison",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CaseInsensitiveComparison\">\r\n    <summary>\r\n    Case-insensitive operations (mostly comparison) on unicode strings.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.CaseInsensitiveComparison",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CaseInsensitiveComparison\">\r\n    <summary>\r\n    Case-insensitive operations (mostly comparison) on unicode strings.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object obj);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DocumentationProvider.Equals(System.Object)\">\r\n    <summary>\r\n    DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.\r\n    Hence, if multiple instances can represent the same documentation, it is imperative that\r\n    Equals (and GetHashCode) be overridden to capture this fact.  Otherwise, it is possible to end\r\n    up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.DocumentationProvider.Equals(System.Object)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DocumentationProvider.Equals(System.Object)\">\r\n    <summary>\r\n    DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.\r\n    Hence, if multiple instances can represent the same documentation, it is imperative that\r\n    Equals (and GetHashCode) be overridden to capture this fact.  Otherwise, it is possible to end\r\n    up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DocumentationProvider.GetHashCode\">\r\n    <summary>\r\n    DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.\r\n    Hence, if multiple instances can represent the same documentation, it is imperative that\r\n    GetHashCode (and Equals) be overridden to capture this fact.  Otherwise, it is possible to end\r\n    up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.DocumentationProvider.GetHashCode",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DocumentationProvider.GetHashCode\">\r\n    <summary>\r\n    DocumentationProviders are compared when determining whether an AssemblySymbol can be reused.\r\n    Hence, if multiple instances can represent the same documentation, it is imperative that\r\n    GetHashCode (and Equals) be overridden to capture this fact.  Otherwise, it is possible to end\r\n    up with multiple AssemblySymbols for the same assembly, which plays havoc with the type hierarchy.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract partial class DocumentationProvider",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DocumentationProvider\">\r\n    <summary>\r\n    A class used to provide XML documentation to the compiler for members from metadata. A\r\n    custom implementation of this class should be returned from a DocumentationResolver to provide XML\r\n    documentation comments from custom caches or locations.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.DocumentationProvider",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DocumentationProvider\">\r\n    <summary>\r\n    A class used to provide XML documentation to the compiler for members from metadata. A\r\n    custom implementation of this class should be returned from a DocumentationResolver to provide XML\r\n    documentation comments from custom caches or locations.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public virtual TResult VisitArrayType(IArrayTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitArrayType(Microsoft.CodeAnalysis.IArrayTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult DefaultVisit(ISymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.DefaultVisit(Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult Visit(ISymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.Visit(Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitRangeVariable(Microsoft.CodeAnalysis.IRangeVariableSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitAlias(IAliasSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitAlias(Microsoft.CodeAnalysis.IAliasSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitLocal(ILocalSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitLocal(Microsoft.CodeAnalysis.ILocalSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitEvent(IEventSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitEvent(Microsoft.CodeAnalysis.IEventSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitNamedType(INamedTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitNamedType(Microsoft.CodeAnalysis.INamedTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitNamespace(INamespaceSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitMethod(IMethodSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitMethod(Microsoft.CodeAnalysis.IMethodSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitPointerType(IPointerTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitPointerType(Microsoft.CodeAnalysis.IPointerTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitDynamicType(Microsoft.CodeAnalysis.IDynamicTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitParameter(IParameterSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitParameter(Microsoft.CodeAnalysis.IParameterSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitLabel(ILabelSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitLabel(Microsoft.CodeAnalysis.ILabelSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitTypeParameter(Microsoft.CodeAnalysis.ITypeParameterSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitAssembly(IAssemblySymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitAssembly(Microsoft.CodeAnalysis.IAssemblySymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitModule(IModuleSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitModule(Microsoft.CodeAnalysis.IModuleSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitProperty(IPropertySymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitProperty(Microsoft.CodeAnalysis.IPropertySymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual TResult VisitField(IFieldSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor`1.VisitField(Microsoft.CodeAnalysis.IFieldSymbol)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class SymbolVisitor<TResult>",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.SymbolVisitor`1",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public class DiagnosticDescriptor",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\">\r\n    <summary>\r\n    Provides a description about a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/>\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.DiagnosticDescriptor",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DiagnosticDescriptor\">\r\n    <summary>\r\n    Provides a description about a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/>\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public static class WellKnownMemberNames",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.WellKnownMemberNames\">\r\n    <summary>\r\n    Specifies the member names known to the compiler (such as <c>.ctor</c> or <c>op_Explicit</c>).\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.WellKnownMemberNames",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.WellKnownMemberNames\">\r\n    <summary>\r\n    Specifies the member names known to the compiler (such as <c>.ctor</c> or <c>op_Explicit</c>).\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic,IFormatProvider)\">\r\n    <summary>\r\n    Formats the <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> message using the optional <see cref=\"!:IFormatProvider\"/>.\r\n    </summary>\r\n    <param name=\"diagnostic\">The diagnostic.</param>\r\n    <param name=\"formatter\">The formatter; or null to use the default formatter.</param>\r\n    <returns>The formatted message.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic,IFormatProvider)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.DiagnosticFormatter.Format(Microsoft.CodeAnalysis.Diagnostic,IFormatProvider)\">\r\n    <summary>\r\n    Formats the <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> message using the optional <see cref=\"!:IFormatProvider\"/>.\r\n    </summary>\r\n    <param name=\"diagnostic\">The diagnostic.</param>\r\n    <param name=\"formatter\">The formatter; or null to use the default formatter.</param>\r\n    <returns>The formatted message.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public class DiagnosticFormatter",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DiagnosticFormatter\">\r\n    <summary>\r\n    Formats <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> messages.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.DiagnosticFormatter",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DiagnosticFormatter\">\r\n    <summary>\r\n    Formats <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> messages.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public static class WellKnownDiagnosticTags",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.WellKnownDiagnosticTags",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static IAliasSymbol GetSpeculativeAliasInfo(this SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the name in the context of the specified location and sees if it resolves to an\r\n    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"nameSyntax\">A syntax node that represents a name. This syntax\r\n    node need not and typically does not appear in the source code referred to by the\r\n    SemanticModel instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the name as a full expression,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <remarks>The passed in name is interpreted as a stand-alone name, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the name in the context of the specified location and sees if it resolves to an\r\n    alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"nameSyntax\">A syntax node that represents a name. This syntax\r\n    node need not and typically does not appear in the source code referred to by the\r\n    SemanticModel instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the name as a full expression,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <remarks>The passed in name is interpreted as a stand-alone name, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ImmutableArray<ISymbol> GetMemberGroup(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetMemberGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static IAliasSymbol GetAliasInfo(this SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If \"nameSyntax\" resolves to an alias name, return the IAliasSymbol corresponding\r\n    to A. Otherwise return null.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"nameSyntax\">Name to get alias info for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the alias information.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    If \"nameSyntax\" resolves to an alias name, return the IAliasSymbol corresponding\r\n    to A. Otherwise return null.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"nameSyntax\">Name to get alias info for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the alias information.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static DataFlowAnalysis AnalyzeDataFlow(this SemanticModel semanticModel, SyntaxNode statementOrExpression)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze data-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TypeInfo GetTypeInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets type information about a syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets type information about a syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TypeInfo GetSpeculativeTypeInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static SymbolInfo GetSpeculativeSymbolInfo(this SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SpeculativeBindingOption)\">\r\n    <summary>\r\n    Binds the node in the context of the specified location and get semantic information\r\n    such as type, symbols and diagnostics. This method is used to get semantic information\r\n    about an expression that did not actually appear in the source code.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"position\">A character position used to identify a declaration scope and\r\n    accessibility. This character position must be within the FullSpan of the Root syntax\r\n    node in this SemanticModel.\r\n    </param>\r\n    <param name=\"expression\">A syntax node that represents a parsed expression. This syntax\r\n    node need not and typically does not appear in the source code referred to  SemanticModel\r\n    instance.</param>\r\n    <param name=\"bindingOption\">Indicates whether to binding the expression as a full expressions,\r\n    or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then\r\n    expression should derive from TypeSyntax.</param>\r\n    <returns>The semantic information for the topmost node of the expression.</returns>\r\n    <remarks>The passed in expression is interpreted as a stand-alone expression, as if it\r\n    appeared by itself somewhere within the scope that encloses \"position\".</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static SymbolInfo GetSymbolInfo(this SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets symbol information about a syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets symbol information about a syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"node\">The syntax node to get semantic information for.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to cancel the\r\n    process of obtaining the semantic info.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ControlFlowAnalysis AnalyzeControlFlow(this SemanticModel semanticModel, SyntaxNode statement)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Analyze control-flow within a part of a method body. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ISymbol GetDeclaredSymbol(this SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbol declared by the node or null if the node is not a declaration.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModelExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,CancellationToken)\">\r\n    <summary>\r\n    Gets the symbol associated with a declaration syntax node.\r\n    </summary>\r\n    <param name=\"semanticModel\"></param>\r\n    <param name=\"declaration\">A syntax node that is a declaration. This can be any type\r\n    derived from MemberDeclarationSyntax, TypeDeclarationSyntax, EnumDeclarationSyntax,\r\n    NamespaceDeclarationSyntax, ParameterSyntax, TypeParameterSyntax, or the alias part of a\r\n    UsingDirectiveSyntax</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param>\r\n    <returns>The symbol declared by the node or null if the node is not a declaration.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static class ModelExtensions",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.ModelExtensions",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Creates a new compilation with an old syntax tree replaced with a new syntax tree.\r\n    Reuses metadata from old compilation object.\r\n    </summary>\r\n    <param name=\"newTree\">The new tree.</param>\r\n    <param name=\"oldTree\">The old tree.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Creates a new compilation with an old syntax tree replaced with a new syntax tree.\r\n    Reuses metadata from old compilation object.\r\n    </summary>\r\n    <param name=\"newTree\">The new tree.</param>\r\n    <param name=\"oldTree\">The old tree.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonWithOptions(CompilationOptions options);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonWithOptions(Microsoft.CodeAnalysis.CompilationOptions)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public INamedTypeSymbol GetSpecialType(SpecialType specialType)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)\">\r\n    <summary>\r\n    Get the symbol for the predefined type from the Cor Library referenced by this\r\n    compilation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)\">\r\n    <summary>\r\n    Get the symbol for the predefined type from the Cor Library referenced by this\r\n    compilation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})\">\r\n    <summary>\r\n    Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees\r\n    added later.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})\">\r\n    <summary>\r\n    Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees\r\n    added later.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)\">\r\n    <summary>\r\n    Returns a new INamedTypeSymbol representing an error type with the given name and arity\r\n    in the given optional container.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateErrorTypeSymbol(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Int32)\">\r\n    <summary>\r\n    Returns a new INamedTypeSymbol representing an error type with the given name and arity\r\n    in the given optional container.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public EmitResult Emit(Stream peStream, string outputName = null, string pdbFilePath = null, Stream pdbStream = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable<ResourceDescription> manifestResources = null, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.Emit(Stream,System.String,System.String,Stream,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},CancellationToken)\">\r\n    <summary>\r\n    Emit the IL for the compiled source code into the specified stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream to which the compilation will be written.</param>\r\n    <param name=\"outputName\">Name of the compilation: file name and extension.  Null to use the compilation name.\r\n    CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to\r\n    and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the \r\n    name of the compilation, may not be visible at runtime and vice-versa.\r\n    </param>\r\n    <param name=\"pdbFilePath\">\r\n    The name of the PDB file embedded in the PE image. \r\n    If not specified, the file name of the source module with an extension changed to \"pdb\" is used.\r\n    Ignored unless <paramref name=\"pdbStream\"/> is non-null.\r\n    </param>\r\n    <param name=\"pdbStream\">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>\r\n    <param name=\"xmlDocumentationStream\">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>\r\n    <param name=\"cancellationToken\">To cancel the emit process.</param>\r\n    <param name=\"win32Resources\">Stream from which the compilation's Win32 resources will be read (in RES format).  \r\n    Null to indicate that there are none. The RES format begins with a null resource entry.</param>\r\n    <param name=\"manifestResources\">List of the compilation's managed resources.  Null to indicate that there are none.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.Emit(Stream,System.String,System.String,Stream,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.Emit(Stream,System.String,System.String,Stream,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},CancellationToken)\">\r\n    <summary>\r\n    Emit the IL for the compiled source code into the specified stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream to which the compilation will be written.</param>\r\n    <param name=\"outputName\">Name of the compilation: file name and extension.  Null to use the compilation name.\r\n    CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to\r\n    and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the \r\n    name of the compilation, may not be visible at runtime and vice-versa.\r\n    </param>\r\n    <param name=\"pdbFilePath\">\r\n    The name of the PDB file embedded in the PE image. \r\n    If not specified, the file name of the source module with an extension changed to \"pdb\" is used.\r\n    Ignored unless <paramref name=\"pdbStream\"/> is non-null.\r\n    </param>\r\n    <param name=\"pdbStream\">Stream to which the compilation's debug info will be written.  Null to forego PDB generation.</param>\r\n    <param name=\"xmlDocumentationStream\">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>\r\n    <param name=\"cancellationToken\">To cancel the emit process.</param>\r\n    <param name=\"win32Resources\">Stream from which the compilation's Win32 resources will be read (in RES format).  \r\n    Null to indicate that there are none. The RES format begins with a null resource entry.</param>\r\n    <param name=\"manifestResources\">List of the compilation's managed resources.  Null to indicate that there are none.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonRemoveSyntaxTrees(IEnumerable<SyntaxTree> trees);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonRemoveSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation WithPreviousSubmission(Compilation newPreviousSubmission)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithPreviousSubmission(Microsoft.CodeAnalysis.Compilation)\">\r\n    <summary>\r\n    Returns a new compilation with the given compilation set as the\r\n    previous submission.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithPreviousSubmission(Microsoft.CodeAnalysis.Compilation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithPreviousSubmission(Microsoft.CodeAnalysis.Compilation)\">\r\n    <summary>\r\n    Returns a new compilation with the given compilation set as the\r\n    previous submission.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.MetadataReference\"/> that corresponds to the assembly symbol. \r\n    </summary>\r\n    <param name=\"assemblySymbol\">The target symbol.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.MetadataReference\"/> that corresponds to the assembly symbol. \r\n    </summary>\r\n    <param name=\"assemblySymbol\">The target symbol.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation WithReferences(IEnumerable<MetadataReference> newReferences)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n    <param name=\"newReferences\">\r\n    The new references.\r\n    </param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n    <param name=\"newReferences\">\r\n    The new references.\r\n    </param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during symbol declaration.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetDeclarationDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during symbol declaration.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetSpecialType(Microsoft.CodeAnalysis.SpecialType)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(CancellationToken)\">\r\n    <summary>\r\n    Returns the Main method that will serves as the entry point of the assembly, if it is\r\n    executable (and not a script).\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetEntryPoint(CancellationToken)\">\r\n    <summary>\r\n    Returns the Main method that will serves as the entry point of the assembly, if it is\r\n    executable (and not a script).\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation AddSyntaxTrees(IEnumerable<SyntaxTree> trees)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})\">\r\n    <summary>\r\n    Creates a new compilation with additional syntax trees.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})\">\r\n    <summary>\r\n    Creates a new compilation with additional syntax trees.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection<uint> updatedMethodTokens, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},Stream,Stream,Stream,ICollection{System.UInt32},CancellationToken)\">\r\n    <summary>\r\n    Emit the differences between the compilation and the previous generation\r\n    for Edit and Continue. The differences are expressed as added and changed\r\n    symbols, and are emitted as metadata, IL, and PDB deltas. A representation\r\n    of the current compilation is returned as an EmitBaseline for use in a\r\n    subsequent Edit and Continue.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},Stream,Stream,Stream,ICollection{System.UInt32},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.EmitDifference(Microsoft.CodeAnalysis.Emit.EmitBaseline,IEnumerable{Microsoft.CodeAnalysis.Emit.SemanticEdit},Stream,Stream,Stream,ICollection{System.UInt32},CancellationToken)\">\r\n    <summary>\r\n    Emit the differences between the compilation and the previous generation\r\n    for Edit and Continue. The differences are expressed as added and changed\r\n    symbols, and are emitted as metadata, IL, and PDB deltas. A representation\r\n    of the current compilation is returned as an EmitBaseline for use in a\r\n    subsequent Edit and Continue.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetTypeByMetadataName(System.String)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation AddSyntaxTrees(params SyntaxTree[] trees)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])\">\r\n    <summary>\r\n    Creates a new compilation with additional syntax trees.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])\">\r\n    <summary>\r\n    Creates a new compilation with additional syntax trees.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank = 1)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)\">\r\n    <summary>\r\n    Returns a new ArrayTypeSymbol representing an array type tied to the base types of the\r\n    COR Library in this Compilation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)\">\r\n    <summary>\r\n    Returns a new ArrayTypeSymbol representing an array type tied to the base types of the\r\n    COR Library in this Compilation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.IAssemblySymbol\"/> or <see cref=\"T:Microsoft.CodeAnalysis.IModuleSymbol\"/> for a metadata reference used to create this\r\n    compilation.\r\n    </summary>\r\n    <param name=\"reference\">The target reference.</param>\r\n    <returns>\r\n    Assembly or module symbol corresponding to the given reference or null if there is none.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)\">\r\n    <summary>\r\n    Gets the <see cref=\"T:Microsoft.CodeAnalysis.IAssemblySymbol\"/> or <see cref=\"T:Microsoft.CodeAnalysis.IModuleSymbol\"/> for a metadata reference used to create this\r\n    compilation.\r\n    </summary>\r\n    <param name=\"reference\">The target reference.</param>\r\n    <returns>\r\n    Assembly or module symbol corresponding to the given reference or null if there is none.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation AddReferences(params MetadataReference[] references)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation with additional metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation with additional metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetEntryPoint(CancellationToken)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)\">\r\n    <summary>\r\n    Creates a new compilation with an old metadata reference replaced with a new metadata\r\n    reference.\r\n    </summary>\r\n    <param name=\"newReference\">The new reference.</param>\r\n    <param name=\"oldReference\">The old reference.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)\">\r\n    <summary>\r\n    Creates a new compilation with an old metadata reference replaced with a new metadata\r\n    reference.\r\n    </summary>\r\n    <param name=\"newReference\">The new reference.</param>\r\n    <param name=\"oldReference\">The old reference.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonWithPreviousSubmission(Compilation newPreviousSubmission);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonWithPreviousSubmission(Microsoft.CodeAnalysis.Compilation)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract CompilationReference ToMetadataReference(ImmutableArray<string> aliases = default (ImmutableArray<string>), bool embedInteropTypes = false);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(ImmutableArray{System.String},System.Boolean)\">\r\n    <summary>\r\n    Creates a metadata reference for this compilation.\r\n    </summary>\r\n    <param name=\"aliases\">\r\n    Optional aliases that can be used to refer to the compilation root namespace via extern alias directive.\r\n    </param>\r\n    <param name=\"embedInteropTypes\">\r\n    Embed the COM types from the reference so that the compiled\r\n    application no longer requires a primary interop assembly (PIA).\r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(ImmutableArray{System.String},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ToMetadataReference(ImmutableArray{System.String},System.Boolean)\">\r\n    <summary>\r\n    Creates a metadata reference for this compilation.\r\n    </summary>\r\n    <param name=\"aliases\">\r\n    Optional aliases that can be used to refer to the compilation root namespace via extern alias directive.\r\n    </param>\r\n    <param name=\"embedInteropTypes\">\r\n    Embed the COM types from the reference so that the compiled\r\n    application no longer requires a primary interop assembly (PIA).\r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract Compilation WithEventQueue(AsyncQueue<CompilationEvent> eventQueue);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})\">\r\n    <summary>\r\n    Returns a new compilation with a given event queue.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})\">\r\n    <summary>\r\n    Returns a new compilation with a given event queue.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonWithAssemblyName(string outputName);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonWithAssemblyName(System.String)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,Stream,Stream)\">\r\n    <summary>\r\n    Create a stream filled with default win32 resources.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,Stream,Stream)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreateDefaultWin32Resources(System.Boolean,System.Boolean,Stream,Stream)\">\r\n    <summary>\r\n    Create a stream filled with default win32 resources.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ITypeSymbol GetSubmissionResultType(out bool hasValue)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSubmissionResultType(System.Boolean@)\">\r\n    <summary>\r\n    Returns the type of the submission return value.\r\n    </summary>\r\n    <param name=\"hasValue\">\r\n    True if the submission has a return value, i.e. if the submission\r\n    ends with an expression statement.\r\n    </param>\r\n    <exception cref=\"!:InvalidOperationException\">\r\n    The compilation doesn't represent a submission\r\n    (<see cref=\"P:Microsoft.CodeAnalysis.Compilation.IsSubmission\"/> return false).\r\n    </exception>\r\n    <returns>\r\n    Null if the type of the last expression is unknown, \r\n    <see cref=\"!:System.Void\"/> if the type of the last expression statement is\r\n    void or if the submission is not an expression statement, or\r\n    otherwise the type of the last expression.\r\n    </returns>\r\n    <remarks>\r\n    Note that the return type is <see cref=\"!:System.Void\"/> if the last\r\n    statement is a non-expression statement e.g.,\r\n    <code>System.Console.WriteLine();</code>\r\n    and if the statement is an expression statement of type void e.g,\r\n    <code>System.Console.WriteLine()</code>. However,\r\n    <paramref name=\"hasValue\"/> is false in the former case and true\r\n    in the latter.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetSubmissionResultType(System.Boolean@)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSubmissionResultType(System.Boolean@)\">\r\n    <summary>\r\n    Returns the type of the submission return value.\r\n    </summary>\r\n    <param name=\"hasValue\">\r\n    True if the submission has a return value, i.e. if the submission\r\n    ends with an expression statement.\r\n    </param>\r\n    <exception cref=\"!:InvalidOperationException\">\r\n    The compilation doesn't represent a submission\r\n    (<see cref=\"P:Microsoft.CodeAnalysis.Compilation.IsSubmission\"/> return false).\r\n    </exception>\r\n    <returns>\r\n    Null if the type of the last expression is unknown, \r\n    <see cref=\"!:System.Void\"/> if the type of the last expression statement is\r\n    void or if the submission is not an expression statement, or\r\n    otherwise the type of the last expression.\r\n    </returns>\r\n    <remarks>\r\n    Note that the return type is <see cref=\"!:System.Void\"/> if the last\r\n    statement is a non-expression statement e.g.,\r\n    <code>System.Console.WriteLine();</code>\r\n    and if the statement is an expression statement of type void e.g,\r\n    <code>System.Console.WriteLine()</code>. However,\r\n    <paramref name=\"hasValue\"/> is false in the former case and true\r\n    in the latter.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool HasCodeToEmit();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.HasCodeToEmit\">\r\n    <summary>\r\n    Return true if the compilation contains any code or types.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.HasCodeToEmit",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.HasCodeToEmit\">\r\n    <summary>\r\n    Return true if the compilation contains any code or types.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SemanticModel GetSemanticModel(SyntaxTree syntaxTree)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Gets a new <see cref=\"T:Microsoft.CodeAnalysis.SemanticModel\"/> for the specified syntax tree.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Gets a new <see cref=\"T:Microsoft.CodeAnalysis.SemanticModel\"/> for the specified syntax tree.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool ContainsSyntaxTree(SyntaxTree syntaxTree)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Returns true if this compilation contains the specified tree. False otherwise.\r\n    </summary>\r\n    <param name=\"syntaxTree\">A syntax tree.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Returns true if this compilation contains the specified tree. False otherwise.\r\n    </summary>\r\n    <param name=\"syntaxTree\">A syntax tree.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract void AppendDefaultVersionResource(Stream resourceStream);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.AppendDefaultVersionResource(Stream)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveSyntaxTrees(params SyntaxTree[] trees)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])\">\r\n    <summary>\r\n    Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees\r\n    added later.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])\">\r\n    <summary>\r\n    Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees\r\n    added later.\r\n    </summary>\r\n    <param name=\"trees\">The new syntax trees.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)\">\r\n    <summary>\r\n    Gets the corresponding compilation namespace for the specified module or assembly namespace.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)\">\r\n    <summary>\r\n    Gets the corresponding compilation namespace for the specified module or assembly namespace.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveReferences(params MetadataReference[] references)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation without the specified metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation without the specified metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)\">\r\n    <summary>\r\n    Returns a new PointerTypeSymbol representing a pointer type tied to a type in this\r\n    Compilation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)\">\r\n    <summary>\r\n    Returns a new PointerTypeSymbol representing a pointer type tied to a type in this\r\n    Compilation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonCreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonRemoveAllSyntaxTrees();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonRemoveAllSyntaxTrees",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during the analysis of method bodies and field initializers.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetMethodBodyDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during the analysis of method bodies and field initializers.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonWithReferences(IEnumerable<MetadataReference> newReferences);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.CommonWithReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonClone();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonClone",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation WithReferences(params MetadataReference[] newReferences)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n    <param name=\"newReferences\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])\">\r\n    <summary>\r\n    Creates a new compilation with the specified references.\r\n    </summary>\r\n    <param name=\"newReferences\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation WithAssemblyName(string assemblyName)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)\">\r\n    <summary>\r\n    Creates a compilation with the specified assembly name.\r\n    </summary>\r\n    <param name=\"assemblyName\">The new assembly name.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithAssemblyName(System.String)\">\r\n    <summary>\r\n    Creates a compilation with the specified assembly name.\r\n    </summary>\r\n    <param name=\"assemblyName\">The new assembly name.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets all the diagnostics for the compilation, including syntax, declaration, and\r\n    binding. Does not include any diagnostics that might be produced during emit, see\r\n    <see cref=\"T:EmitResult\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets all the diagnostics for the compilation, including syntax, declaration, and\r\n    binding. Does not include any diagnostics that might be produced during emit, see\r\n    <see cref=\"T:EmitResult\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation AddReferences(IEnumerable<MetadataReference> references)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with additional metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.AddReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.AddReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation with additional metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation Clone()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.Clone\">\r\n    <summary>\r\n    Creates a new compilation equivalent to this one with different symbol instances.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.Clone",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.Clone\">\r\n    <summary>\r\n    Creates a new compilation equivalent to this one with different symbol instances.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation WithOptions(CompilationOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)\">\r\n    <summary>\r\n    Creates a new compilation with the specified compilation options.\r\n    </summary>\r\n    <param name=\"options\">The new options.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.WithOptions(Microsoft.CodeAnalysis.CompilationOptions)\">\r\n    <summary>\r\n    Creates a new compilation with the specified compilation options.\r\n    </summary>\r\n    <param name=\"options\">The new options.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during the parsing stage.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetParseDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets the diagnostics produced during the parsing stage.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonCreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveReferences(IEnumerable<MetadataReference> references)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation without the specified metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveReferences(IEnumerable{Microsoft.CodeAnalysis.MetadataReference})\">\r\n    <summary>\r\n    Creates a new compilation without the specified metadata references.\r\n    </summary>\r\n    <param name=\"references\">The new references.</param>\r\n    <returns>A new compilation.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)\">\r\n    <summary>\r\n    Gets the type within the compilation's assembly and all referenced assemblies (other than\r\n    those that can only be referenced via an extern alias) using its canonical CLR metadata name.\r\n    </summary>\r\n    <returns>Null if the type can't be found.</returns>\r\n    <remarks>\r\n    Since VB does not have the concept of extern aliases, it considers all referenced assemblies.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.GetTypeByMetadataName(System.String)\">\r\n    <summary>\r\n    Gets the type within the compilation's assembly and all referenced assemblies (other than\r\n    those that can only be referenced via an extern alias) using its canonical CLR metadata name.\r\n    </summary>\r\n    <returns>Null if the type can't be found.</returns>\r\n    <remarks>\r\n    Since VB does not have the concept of extern aliases, it considers all referenced assemblies.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract MetadataReference CommonGetMetadataReference(IAssemblySymbol assemblySymbol);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public EmitResult EmitMetadataOnly(Stream peStream, string outputName = null, Stream xmlDocumentationStream = null, Stream win32Resources = null, IEnumerable<ResourceDescription> manifestResources = null, MetadataOnlyEmitOptions emitOptions = default (MetadataOnlyEmitOptions), CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.EmitMetadataOnly(Stream,System.String,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.MetadataOnlyEmitOptions,CancellationToken)\">\r\n    <summary>\r\n    Emits the IL for the symbol declarations into the specified stream. Useful for emitting\r\n    information for cross-language modeling of code. This emits what it can even if there\r\n    are errors.\r\n    </summary>\r\n    <param name=\"peStream\">Stream to which the PE image with metadata will be written.</param>\r\n    <param name=\"xmlDocumentationStream\">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>\r\n    <param name=\"outputName\">Name of the compilation: file name and extension.  Null to use the existing output name.\r\n    CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to\r\n    and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the \r\n    name of the compilation, may not be visible at runtime and vice-versa.\r\n    </param>\r\n    <param name=\"win32Resources\">Stream from which the compilation's Win32 resources will be read (in RES format).  \r\n    Null to indicate that there are none. The RES format begins with a null resource entry.</param>\r\n    <param name=\"manifestResources\">List of the compilation's managed resources.  Null to indicate that there are none.</param>\r\n    <param name=\"emitOptions\">Options controlling the emitted metadata.</param>\r\n    <param name=\"cancellationToken\">To cancel the emit process.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.EmitMetadataOnly(Stream,System.String,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.MetadataOnlyEmitOptions,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.EmitMetadataOnly(Stream,System.String,Stream,Stream,IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},Microsoft.CodeAnalysis.MetadataOnlyEmitOptions,CancellationToken)\">\r\n    <summary>\r\n    Emits the IL for the symbol declarations into the specified stream. Useful for emitting\r\n    information for cross-language modeling of code. This emits what it can even if there\r\n    are errors.\r\n    </summary>\r\n    <param name=\"peStream\">Stream to which the PE image with metadata will be written.</param>\r\n    <param name=\"xmlDocumentationStream\">Stream to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>\r\n    <param name=\"outputName\">Name of the compilation: file name and extension.  Null to use the existing output name.\r\n    CAUTION: If this is set to a (non-null) value other than the existing compilation output name, then internals-visible-to\r\n    and assembly references may not work as expected.  In particular, things that were visible at bind time, based on the \r\n    name of the compilation, may not be visible at runtime and vice-versa.\r\n    </param>\r\n    <param name=\"win32Resources\">Stream from which the compilation's Win32 resources will be read (in RES format).  \r\n    Null to indicate that there are none. The RES format begins with a null resource entry.</param>\r\n    <param name=\"manifestResources\">List of the compilation's managed resources.  Null to indicate that there are none.</param>\r\n    <param name=\"emitOptions\">Options controlling the emitted metadata.</param>\r\n    <param name=\"cancellationToken\">To cancel the emit process.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ITypeSymbol CommonGetSubmissionResultType(out bool hasValue);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonGetSubmissionResultType(System.Boolean@)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveAllReferences()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences\">\r\n    <summary>\r\n    Creates a new compilation without any metadata references.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveAllReferences\">\r\n    <summary>\r\n    Creates a new compilation without any metadata references.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Compilation RemoveAllSyntaxTrees()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees\">\r\n    <summary>\r\n    Creates a new compilation without any syntax trees. Preserves metadata info for use with\r\n    trees added later.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Compilation.RemoveAllSyntaxTrees\">\r\n    <summary>\r\n    Creates a new compilation without any syntax trees. Preserves metadata info for use with\r\n    trees added later.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Compilation CommonAddSyntaxTrees(IEnumerable<SyntaxTree> trees);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Compilation.CommonAddSyntaxTrees(IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract partial class Compilation\r\n\r\n#endregion",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Compilation\">\r\n    <summary>\r\n    The compilation object is an immutable representation of a single invocation of the\r\n    compiler. Although immutable, a compilation is also on-demand, and will realize and cache\r\n    data as necessary. A compilation can produce a new compilation from existing compilation\r\n    with the application of small deltas. In many cases, it is more efficient than creating a\r\n    new compilation from scratch, as the new compilation can reuse information from the old\r\n    compilation.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Compilation",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Compilation\">\r\n    <summary>\r\n    The compilation object is an immutable representation of a single invocation of the\r\n    compiler. Although immutable, a compilation is also on-demand, and will realize and cache\r\n    data as necessary. A compilation can produce a new compilation from existing compilation\r\n    with the application of small deltas. In many cases, it is more efficient than creating a\r\n    new compilation from scratch, as the new compilation can reuse information from the old\r\n    compilation.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public virtual void VisitAlias(IAliasSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitAlias(Microsoft.CodeAnalysis.IAliasSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitMethod(IMethodSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitMethod(Microsoft.CodeAnalysis.IMethodSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitDynamicType(IDynamicTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitDynamicType(Microsoft.CodeAnalysis.IDynamicTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitPointerType(IPointerTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitPointerType(Microsoft.CodeAnalysis.IPointerTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitNamedType(INamedTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitNamedType(Microsoft.CodeAnalysis.INamedTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitEvent(IEventSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitEvent(Microsoft.CodeAnalysis.IEventSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitModule(IModuleSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitModule(Microsoft.CodeAnalysis.IModuleSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitField(IFieldSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitField(Microsoft.CodeAnalysis.IFieldSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitArrayType(IArrayTypeSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitArrayType(Microsoft.CodeAnalysis.IArrayTypeSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitLabel(ILabelSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitLabel(Microsoft.CodeAnalysis.ILabelSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitTypeParameter(ITypeParameterSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitTypeParameter(Microsoft.CodeAnalysis.ITypeParameterSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitParameter(IParameterSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitParameter(Microsoft.CodeAnalysis.IParameterSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitLocal(ILocalSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitLocal(Microsoft.CodeAnalysis.ILocalSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitProperty(IPropertySymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitProperty(Microsoft.CodeAnalysis.IPropertySymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void DefaultVisit(ISymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.DefaultVisit(Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitAssembly(IAssemblySymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitAssembly(Microsoft.CodeAnalysis.IAssemblySymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitNamespace(INamespaceSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void Visit(ISymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.Visit(Microsoft.CodeAnalysis.ISymbol)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual void VisitRangeVariable(IRangeVariableSymbol symbol)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolVisitor.VisitRangeVariable(Microsoft.CodeAnalysis.IRangeVariableSymbol)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class SymbolVisitor",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.SymbolVisitor",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected abstract ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.CommonWithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected bool EqualsHelper(ParseOptions other)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.EqualsHelper(Microsoft.CodeAnalysis.ParseOptions)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public ParseOptions WithKind(SourceCodeKind kind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)\">\r\n    <summary>\r\n    Creates a new options instance with the specified source code kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ParseOptions.WithKind(Microsoft.CodeAnalysis.SourceCodeKind)\">\r\n    <summary>\r\n    Creates a new options instance with the specified source code kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object obj);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public ParseOptions WithDocumentationMode(DocumentationMode documentationMode)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)\">\r\n    <summary>\r\n    Creates a new options instance with the specified documentation mode.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ParseOptions.WithDocumentationMode(Microsoft.CodeAnalysis.DocumentationMode)\">\r\n    <summary>\r\n    Creates a new options instance with the specified documentation mode.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract ParseOptions CommonWithKind(SourceCodeKind kind);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.CommonWithKind(Microsoft.CodeAnalysis.SourceCodeKind)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected int GetHashCodeHelper()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ParseOptions.GetHashCodeHelper",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class ParseOptions",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ParseOptions\">\r\n    <summary>\r\n    Represents parse options common to C# and VB.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.ParseOptions",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ParseOptions\">\r\n    <summary>\r\n    Represents parse options common to C# and VB.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public Guid GetModuleVersionId()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleVersionId\">\r\n    <summary>\r\n    Version of the module content.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">Invalid metadata.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">Module has been disposed.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleVersionId",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleVersionId\">\r\n    <summary>\r\n    Version of the module content.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">Invalid metadata.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">Module has been disposed.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromImage(ImmutableArray<byte> peImage)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\">\r\n    <summary>\r\n    Create metadata module from a byte array.\r\n    </summary>\r\n    <param name=\"peImage\">Portable executable image beginning with the DOS header (\"MZ\").</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\">\r\n    <summary>\r\n    Create metadata module from a byte array.\r\n    </summary>\r\n    <param name=\"peImage\">Portable executable image beginning with the DOS header (\"MZ\").</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromImage(IEnumerable<byte> peImage)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IEnumerable{System.Byte})\">\r\n    <summary>\r\n    Create metadata module from a sequence of bytes.\r\n    </summary>\r\n    <param name=\"peImage\">The portable executable image beginning with the DOS header (\"MZ\").</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IEnumerable{System.Byte})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IEnumerable{System.Byte})\">\r\n    <summary>\r\n    Create metadata module from a sequence of bytes.\r\n    </summary>\r\n    <param name=\"peImage\">The portable executable image beginning with the DOS header (\"MZ\").</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public override void Dispose()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.Dispose\">\r\n    <summary>\r\n    Frees memory and handles allocated for the module.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.Dispose",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.Dispose\">\r\n    <summary>\r\n    Frees memory and handles allocated for the module.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected override Metadata CommonCopy()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CommonCopy",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,System.Boolean)\">\r\n    <summary>\r\n    Create metadata module from a stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream containing portable executable image. Position zero should contain the first byte of the DOS header (\"MZ\").</param>\r\n    <param name=\"leaveOpen\">\r\n    False to close the stream upon disposal of the metadata (the responsibility for disposal of the stream is transferred upon entry of the constructor\r\n    unless the arguments given are invalid).\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">The stream doesn't support seek operations.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,System.Boolean)\">\r\n    <summary>\r\n    Create metadata module from a stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream containing portable executable image. Position zero should contain the first byte of the DOS header (\"MZ\").</param>\r\n    <param name=\"leaveOpen\">\r\n    False to close the stream upon disposal of the metadata (the responsibility for disposal of the stream is transferred upon entry of the constructor\r\n    unless the arguments given are invalid).\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">The stream doesn't support seek operations.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,PEStreamOptions)\">\r\n    <summary>\r\n    Create metadata module from a stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream containing portable executable image. Position zero should contain the first byte of the DOS header (\"MZ\").</param>\r\n    <param name=\"options\">\r\n    Options specifying how sections of the PE image are read from the stream.\r\n    Unless <see cref=\"!:PEStreamOptions.LeaveOpen\"/> is specified, the responsibility for disposal of the stream is transferred upon entry of the constructor\r\n    unless the arguments given are invalid.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">The stream doesn't support read and seek operations.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"options\"/> has an invalid value.</exception>\r\n    <exception cref=\"!:BadImageFormatException\">\r\n    <see cref=\"!:PEStreamOptions.PrefetchMetadata\"/> or <see cref=\"!:PEStreamOptions.PrefetchEntireImage\"/> is specified and the PE headers of the image are invalid.\r\n    </exception>\r\n    <exception cref=\"!:IOException\">\r\n    <see cref=\"!:PEStreamOptions.PrefetchMetadata\"/> or <see cref=\"!:PEStreamOptions.PrefetchEntireImage\"/> is specified and an error occurs while reading the stream.\r\n    </exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,PEStreamOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,PEStreamOptions)\">\r\n    <summary>\r\n    Create metadata module from a stream.\r\n    </summary>\r\n    <param name=\"peStream\">Stream containing portable executable image. Position zero should contain the first byte of the DOS header (\"MZ\").</param>\r\n    <param name=\"options\">\r\n    Options specifying how sections of the PE image are read from the stream.\r\n    Unless <see cref=\"!:PEStreamOptions.LeaveOpen\"/> is specified, the responsibility for disposal of the stream is transferred upon entry of the constructor\r\n    unless the arguments given are invalid.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\">The stream doesn't support read and seek operations.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"options\"/> has an invalid value.</exception>\r\n    <exception cref=\"!:BadImageFormatException\">\r\n    <see cref=\"!:PEStreamOptions.PrefetchMetadata\"/> or <see cref=\"!:PEStreamOptions.PrefetchEntireImage\"/> is specified and the PE headers of the image are invalid.\r\n    </exception>\r\n    <exception cref=\"!:IOException\">\r\n    <see cref=\"!:PEStreamOptions.PrefetchMetadata\"/> or <see cref=\"!:PEStreamOptions.PrefetchEntireImage\"/> is specified and an error occurs while reading the stream.\r\n    </exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<string> GetModuleNames()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleNames\">\r\n    <summary>\r\n    Returns the file names of linked managed modules.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">When an invalid module name is encountered.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">Module has been disposed.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleNames",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetModuleNames\">\r\n    <summary>\r\n    Returns the file names of linked managed modules.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">When an invalid module name is encountered.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">Module has been disposed.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromImage(IntPtr peImage, int size)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IntPtr,System.Int32)\">\r\n    <summary>\r\n    Create metadata module from a raw memory pointer to a PE image or an object file.\r\n    </summary>\r\n    <param name=\"peImage\">Pointer to the DOS header (\"MZ\") of a portable executable image.</param>\r\n    <param name=\"size\">The size of the image pointed to by <paramref name=\"peImage\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"size\"/> is not positive.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IntPtr,System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IntPtr,System.Int32)\">\r\n    <summary>\r\n    Create metadata module from a raw memory pointer to a PE image or an object file.\r\n    </summary>\r\n    <param name=\"peImage\">Pointer to the DOS header (\"MZ\") of a portable executable image.</param>\r\n    <param name=\"size\">The size of the image pointed to by <paramref name=\"peImage\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"size\"/> is not positive.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public PortableExecutableReference GetReference(DocumentationProvider documentation = null, string filePath = null, string display = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)\">\r\n    <summary>\r\n    Creates a reference to the module metadata.\r\n    </summary>\r\n    <param name=\"documentation\">Provider of XML documentation comments for the metadata symbols contained in the module.</param>\r\n    <param name=\"filePath\">Path describing the location of the metadata, or null if the metadata have no location.</param>\r\n    <param name=\"display\">Display string used in error messages to identity the reference.</param>\r\n    <returns>A reference to the module metadata.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)\">\r\n    <summary>\r\n    Creates a reference to the module metadata.\r\n    </summary>\r\n    <param name=\"documentation\">Provider of XML documentation comments for the metadata symbols contained in the module.</param>\r\n    <param name=\"filePath\">Path describing the location of the metadata, or null if the metadata have no location.</param>\r\n    <param name=\"display\">Display string used in error messages to identity the reference.</param>\r\n    <returns>A reference to the module metadata.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(IntPtr,System.Int32)\">\r\n    <summary>\r\n    Create metadata module from a raw memory pointer to metadata directory of a PE image or .cormeta section of an object file.\r\n    Only manifest modules are currently supported.\r\n    </summary>\r\n    <param name=\"metadata\">Pointer to the start of metadata block.</param>\r\n    <param name=\"size\">The size of the metadata block.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"metadata\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"size\"/> is not positive.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(IntPtr,System.Int32)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromMetadata(IntPtr,System.Int32)\">\r\n    <summary>\r\n    Create metadata module from a raw memory pointer to metadata directory of a PE image or .cormeta section of an object file.\r\n    Only manifest modules are currently supported.\r\n    </summary>\r\n    <param name=\"metadata\">Pointer to the start of metadata block.</param>\r\n    <param name=\"size\">The size of the metadata block.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"metadata\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\"><paramref name=\"size\"/> is not positive.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static ModuleMetadata CreateFromFile(string path)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)\">\r\n    <summary>\r\n    Creates metadata module from a file containing a portable executable image.\r\n    </summary>\r\n    <param name=\"path\">File path.</param>\r\n    <remarks>\r\n    The file might remain mapped (and read-locked) until this object is disposed.\r\n    The memory map is only created for large files. Small files are read into memory.\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">Error opening file <paramref name=\"path\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:FileNotFoundException\">File <paramref name=\"path\"/> not found.</exception>\r\n    <exception cref=\"!:NotSupportedException\">Reading from a file path is not supported by the platform.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)\">\r\n    <summary>\r\n    Creates metadata module from a file containing a portable executable image.\r\n    </summary>\r\n    <param name=\"path\">File path.</param>\r\n    <remarks>\r\n    The file might remain mapped (and read-locked) until this object is disposed.\r\n    The memory map is only created for large files. Small files are read into memory.\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">Error opening file <paramref name=\"path\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:FileNotFoundException\">File <paramref name=\"path\"/> not found.</exception>\r\n    <exception cref=\"!:NotSupportedException\">Reading from a file path is not supported by the platform.</exception>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public sealed partial class ModuleMetadata",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ModuleMetadata\">\r\n    <summary>\r\n    Represents an immutable snapshot of module CLI metadata.\r\n    </summary>\r\n    <remarks>This object may allocate significant resources or lock files depending upon how it is constructed.</remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.ModuleMetadata",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ModuleMetadata\">\r\n    <summary>\r\n    Represents an immutable snapshot of module CLI metadata.\r\n    </summary>\r\n    <remarks>This object may allocate significant resources or lock files depending upon how it is constructed.</remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters that should not be applied when formatting parameters.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters that should not be applied when formatting parameters.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    The settings that determine other characteristics of how symbols are displayed.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    The settings that determine other characteristics of how symbols are displayed.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how generic symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how generic symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying which parameters should not be applied to how members will be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.RemoveMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/> stripped away from the original object.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying which parameters should not be applied to how members will be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/> stripped away from the original object.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how miscellaneous symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how miscellaneous symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle\"/>.\r\n    </summary>\r\n    <param name=\"style\">\r\n    An object specifying paramers on how namespace symbols should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGlobalNamespaceStyle(Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle\"/>.\r\n    </summary>\r\n    <param name=\"style\">\r\n    An object specifying paramers on how namespace symbols should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how members will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how members will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how members will be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddMemberOptions(Microsoft.CodeAnalysis.SymbolDisplayMemberOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters for how members will be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMemberOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how parameters should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how parameters should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters with which symbols belonging to kind keywords should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters with which symbols belonging to kind keywords should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters on how symbols belonging to locals should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters on how symbols belonging to locals should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters on how parameters should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.AddParameterOptions(Microsoft.CodeAnalysis.SymbolDisplayParameterOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying additional parameters on how parameters should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with an additional set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayParameterOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters on how symbols belonging to locals should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithLocalOptions(Microsoft.CodeAnalysis.SymbolDisplayLocalOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters on how symbols belonging to locals should be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayLocalOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object representing how miscellaneous symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithMiscellaneousOptions(Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object representing how miscellaneous symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how generic symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithGenericsOptions(Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying how generic symbols will be formatted.\r\n    </param>\r\n    <returns>A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions\"/>.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters with which symbols belonging to kind keywords should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayFormat.WithKindOptions(Microsoft.CodeAnalysis.SymbolDisplayKindOptions)\">\r\n    <summary>\r\n    Creates a copy of the SymbolDisplayFormat but with replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </summary>\r\n    <param name=\"options\">\r\n    An object specifying parameters with which symbols belonging to kind keywords should be formatted.\r\n    </param>\r\n    <returns>\r\n    A duplicate of the SymbolDisplayFormat, with a replaced set of <seealso cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayKindOptions\"/>.\r\n    </returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public class SymbolDisplayFormat",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SymbolDisplayFormat\">\r\n    <summary>\r\n    Describes the formatting rules that should be used when displaying symbols.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SymbolDisplayFormat",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SymbolDisplayFormat\">\r\n    <summary>\r\n    Describes the formatting rules that should be used when displaying symbols.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public new PortableExecutableReference WithAliases(IEnumerable<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Metadata GetMetadataImpl();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataImpl\">\r\n     <summary>\r\n     Get metadata representation for the PE file.\r\n     </summary>\r\n     <exception cref=\"!:BadImageFormatException\">If the PE image format is invalid.</exception>\r\n     <exception cref=\"!:IOException\">The metadata image content can't be read.</exception>\r\n     <exception cref=\"!:FileNotFoundException\">The metadata image is stored in a file that can't be found.</exception>\r\n     <remarks>\r\n     Called when the <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> needs to read the reference metadata.\r\n     \r\n     The listed exceptions are caught and converted to compilation diagnostics.\r\n     Any other exception is considered an unexpected error in the implementation and is not caught.\r\n    \r\n     <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> objects may cache information decoded from the PE image.\r\n     Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> instances accross metadata references will result in better performance.\r\n     \r\n     The calling <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> doesn't take ownership of the <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> objects returned by this method.\r\n     The implementation needs to retrieve the object from a provider that manages their lifetime (such as metadata cache).\r\n     The <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object is kept alive by the <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> that called <see cref=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata\"/>\r\n     and by all compilations created from it via calls to With- factory methods on <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/>, \r\n     other than <see cref=\"M:Compilation.WithReferences\"/> overloads. A compilation created using \r\n     <see cref=\"M:Compilation.WithReferences\"/> will call to <see cref=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata\"/> again.\r\n     </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataImpl",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadataImpl\">\r\n     <summary>\r\n     Get metadata representation for the PE file.\r\n     </summary>\r\n     <exception cref=\"!:BadImageFormatException\">If the PE image format is invalid.</exception>\r\n     <exception cref=\"!:IOException\">The metadata image content can't be read.</exception>\r\n     <exception cref=\"!:FileNotFoundException\">The metadata image is stored in a file that can't be found.</exception>\r\n     <remarks>\r\n     Called when the <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> needs to read the reference metadata.\r\n     \r\n     The listed exceptions are caught and converted to compilation diagnostics.\r\n     Any other exception is considered an unexpected error in the implementation and is not caught.\r\n    \r\n     <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> objects may cache information decoded from the PE image.\r\n     Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> instances accross metadata references will result in better performance.\r\n     \r\n     The calling <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> doesn't take ownership of the <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> objects returned by this method.\r\n     The implementation needs to retrieve the object from a provider that manages their lifetime (such as metadata cache).\r\n     The <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object is kept alive by the <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/> that called <see cref=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata\"/>\r\n     and by all compilations created from it via calls to With- factory methods on <see cref=\"T:Microsoft.CodeAnalysis.Compilation\"/>, \r\n     other than <see cref=\"M:Compilation.WithReferences\"/> overloads. A compilation created using \r\n     <see cref=\"M:Compilation.WithReferences\"/> will call to <see cref=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.GetMetadata\"/> again.\r\n     </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new PortableExecutableReference WithProperties(MetadataReferenceProperties properties)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new PortableExecutableReference WithAliases(ImmutableArray<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(ImmutableArray{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new PortableExecutableReference WithEmbedInteropTypes(bool value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.WithEmbedInteropTypes(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract DocumentationProvider CreateDocumentationProvider();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.CreateDocumentationProvider\">\r\n    <summary>\r\n    Create documentation provider for the reference.\r\n    </summary>\r\n    <remarks>\r\n    Called when the compiler needs to read the documentation for the reference. \r\n    This method is called at most once per metadata reference and its result is cached on the reference object.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.CreateDocumentationProvider",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.CreateDocumentationProvider\">\r\n    <summary>\r\n    Create documentation provider for the reference.\r\n    </summary>\r\n    <remarks>\r\n    Called when the compiler needs to read the documentation for the reference. \r\n    This method is called at most once per metadata reference and its result is cached on the reference object.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithPropertiesImpl(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:NotSupportedException\">Specified values not supported.</exception> \r\n    <remarks>Only invoked if the properties changed.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.PortableExecutableReference.WithPropertiesImpl(Microsoft.CodeAnalysis.MetadataReferenceProperties)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.PortableExecutableReference.WithPropertiesImpl(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:NotSupportedException\">Specified values not supported.</exception> \r\n    <remarks>Only invoked if the properties changed.</remarks>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class PortableExecutableReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\">\r\n    <summary>\r\n    Reference to metadata stored in the standard ECMA-335 metadata format.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.PortableExecutableReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\">\r\n    <summary>\r\n    Reference to metadata stored in the standard ECMA-335 metadata format.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object other);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.StrongNameProvider.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.StrongNameProvider.GetHashCode",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class StrongNameProvider",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.StrongNameProvider\">\r\n    <summary>\r\n    Provides strong name and signs source assemblies.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.StrongNameProvider",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.StrongNameProvider\">\r\n    <summary>\r\n    Provides strong name and signs source assemblies.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class ResourceDescription",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ResourceDescription\">\r\n    <summary>\r\n    Representation of a resource whose contents are to be embedded in the output assembly.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.ResourceDescription",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.ResourceDescription\">\r\n    <summary>\r\n    Representation of a resource whose contents are to be embedded in the output assembly.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override void Dispose()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\">\r\n    <summary>\r\n    Disposes all modules contained in the assembly.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\">\r\n    <summary>\r\n    Disposes all modules contained in the assembly.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata Create(params ModuleMetadata[] modules)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata[])\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata[])\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata CreateFromImage(IEnumerable<byte> peImage)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(IEnumerable{System.Byte})\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peImage\">\r\n    Manifest module image.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(IEnumerable{System.Byte})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(IEnumerable{System.Byte})\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peImage\">\r\n    Manifest module image.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public PortableExecutableReference GetReference(DocumentationProvider documentation = null, ImmutableArray<string> aliases = default (ImmutableArray<string>), bool embedInteropTypes = false, string filePath = null, string display = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\">\r\n    <summary>\r\n    Creates a reference to the assembly metadata.\r\n    </summary>\r\n    <param name=\"documentation\">Provider of XML documentation comments for the metadata symbols contained in the module.</param>\r\n    <param name=\"aliases\">Aliases that can be used to refer to the assembly from source code (see \"extern alias\" directive in C#).</param>\r\n    <param name=\"embedInteropTypes\">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>\r\n    <param name=\"filePath\">Path describing the location of the metadata, or null if the metadata have no location.</param>\r\n    <param name=\"display\">Display string used in error messages to identity the reference.</param>\r\n    <returns>A reference to the assembly metadata.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\">\r\n    <summary>\r\n    Creates a reference to the assembly metadata.\r\n    </summary>\r\n    <param name=\"documentation\">Provider of XML documentation comments for the metadata symbols contained in the module.</param>\r\n    <param name=\"aliases\">Aliases that can be used to refer to the assembly from source code (see \"extern alias\" directive in C#).</param>\r\n    <param name=\"embedInteropTypes\">True to embed interop types from the referenced assembly to the referencing compilation. Must be false for a module.</param>\r\n    <param name=\"filePath\">Path describing the location of the metadata, or null if the metadata have no location.</param>\r\n    <param name=\"display\">Display string used in error messages to identity the reference.</param>\r\n    <returns>A reference to the assembly metadata.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<ModuleMetadata> GetModules()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetModules\">\r\n    <summary>\r\n    Modules comprising this assembly. The first module is the manifest module.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n    <exception cref=\"!:IOException\">IO error reading the metadata. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">The object has been disposed.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.GetModules",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetModules\">\r\n    <summary>\r\n    Modules comprising this assembly. The first module is the manifest module.\r\n    </summary>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n    <exception cref=\"!:IOException\">IO error reading the metadata. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:ObjectDisposedException\">The object has been disposed.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,System.Boolean)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peStream\">Manifest module PE image stream.</param>\r\n    <param name=\"leaveOpen\">False to close the stream upon disposal of the metadata.</param>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,System.Boolean)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peStream\">Manifest module PE image stream.</param>\r\n    <param name=\"leaveOpen\">False to close the stream upon disposal of the metadata.</param>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata Create(IEnumerable<ModuleMetadata> modules)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(IEnumerable{Microsoft.CodeAnalysis.ModuleMetadata})\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">\r\n    Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(IEnumerable{Microsoft.CodeAnalysis.ModuleMetadata})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(IEnumerable{Microsoft.CodeAnalysis.ModuleMetadata})\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">\r\n    Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata CreateFromFile(string path)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\">\r\n    <summary>\r\n    Finds all modules of an assembly on a specified path and builds an instance of <see cref=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\"/> that represents them.\r\n    </summary>\r\n    <param name=\"path\">The full path to the assembly on disk.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"path\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:NotSupportedException\">Reading from a file path is not supported by the platform.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\">\r\n    <summary>\r\n    Finds all modules of an assembly on a specified path and builds an instance of <see cref=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\"/> that represents them.\r\n    </summary>\r\n    <param name=\"path\">The full path to the assembly on disk.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"path\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n    <exception cref=\"!:NotSupportedException\">Reading from a file path is not supported by the platform.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected override Metadata CommonCopy()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CommonCopy",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata Create(ImmutableArray<ModuleMetadata> modules)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(ImmutableArray{Microsoft.CodeAnalysis.ModuleMetadata})\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">\r\n    Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(ImmutableArray{Microsoft.CodeAnalysis.ModuleMetadata})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(ImmutableArray{Microsoft.CodeAnalysis.ModuleMetadata})\">\r\n    <summary>\r\n    Creates a multi-module assembly.\r\n    </summary>\r\n    <param name=\"modules\">\r\n    Modules comprising the assembly. The first module is the manifest module of the assembly.</param>\r\n    <remarks>This object disposes the elements of <paramref name=\"modules\"/> it when it is itself <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Dispose\"/>.</remarks>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is default value.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"modules\"/> contains null elements.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"modules\"/> is empty or contains a module that doesn't own its image (was created via <see cref=\"M:MetadataModule.Copy\"/>).</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata Create(ModuleMetadata module)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"module\">\r\n    Manifest module.\r\n    </param>\r\n    <remarks>This object disposes <paramref name=\"module\"/> it when it is itself disposed.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.Create(Microsoft.CodeAnalysis.ModuleMetadata)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"module\">\r\n    Manifest module.\r\n    </param>\r\n    <remarks>This object disposes <paramref name=\"module\"/> it when it is itself disposed.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peStream\">Manifest module PE image stream.</param>\r\n    <param name=\"options\">False to close the stream upon disposal of the metadata.</param>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peStream\">Manifest module PE image stream.</param>\r\n    <param name=\"options\">False to close the stream upon disposal of the metadata.</param>\r\n    <exception cref=\"!:BadImageFormatException\">The PE image format is invalid.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyMetadata CreateFromImage(ImmutableArray<byte> peImage)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peImage\">\r\n    Manifest module image.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\">\r\n    <summary>\r\n    Creates a single-module assembly.\r\n    </summary>\r\n    <param name=\"peImage\">\r\n    Manifest module image.\r\n    </param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public sealed class AssemblyMetadata",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\">\r\n    <summary>\r\n    Represents an immutable snapshot of assembly CLI metadata.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.AssemblyMetadata",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\">\r\n    <summary>\r\n    Represents an immutable snapshot of assembly CLI metadata.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public class TriggerDiagnosticDescriptor",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.TriggerDiagnosticDescriptor\">\r\n    <summary>\r\n    Provides a description about a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> that is a trigger for some custom behavior for code analyis clients.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.TriggerDiagnosticDescriptor",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.TriggerDiagnosticDescriptor\">\r\n    <summary>\r\n    Provides a description about a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostic\"/> that is a trigger for some custom behavior for code analyis clients.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override bool Equals(object obj)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(System.Object)\">\r\n    <summary>\r\n    Determines whether the specified instance is equal to the current instance.\r\n    </summary>\r\n    <param name=\"obj\">The object to be compared with the current instance.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(System.Object)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(System.Object)\">\r\n    <summary>\r\n    Determines whether the specified instance is equal to the current instance.\r\n    </summary>\r\n    <param name=\"obj\">The object to be compared with the current instance.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity, out AssemblyIdentityParts parts)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyIdentityParts@)\">\r\n    <summary>\r\n    Parses display name filling defaults for any basic properties that are missing.\r\n    </summary>\r\n    <param name=\"displayName\">Display name.</param>\r\n    <param name=\"identity\">A full assembly identity.</param>\r\n    <param name=\"parts\">\r\n    Parts of the assembly identity that were specified in the display name, \r\n    or 0 if the parsing failed.\r\n    </param>\r\n    <returns>True if display name parsed correctly.</returns>\r\n    <remarks>\r\n    The simple name has to be non-empty.\r\n    A partially specified version might be missing build and/or revision number. The default value for these is 65535.\r\n    The default culture is neutral (<see cref=\"P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName\"/> is <see cref=\"!:String.Empty\"/>.\r\n    If neither public key nor token is specified the identity is considered weak.\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"displayName\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyIdentityParts@)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@,Microsoft.CodeAnalysis.AssemblyIdentityParts@)\">\r\n    <summary>\r\n    Parses display name filling defaults for any basic properties that are missing.\r\n    </summary>\r\n    <param name=\"displayName\">Display name.</param>\r\n    <param name=\"identity\">A full assembly identity.</param>\r\n    <param name=\"parts\">\r\n    Parts of the assembly identity that were specified in the display name, \r\n    or 0 if the parsing failed.\r\n    </param>\r\n    <returns>True if display name parsed correctly.</returns>\r\n    <remarks>\r\n    The simple name has to be non-empty.\r\n    A partially specified version might be missing build and/or revision number. The default value for these is 65535.\r\n    The default culture is neutral (<see cref=\"P:Microsoft.CodeAnalysis.AssemblyIdentity.CultureName\"/> is <see cref=\"!:String.Empty\"/>.\r\n    If neither public key nor token is specified the identity is considered weak.\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"displayName\"/> is null.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.FromAssemblyDefinition(Assembly)\">\r\n    <summary>\r\n    Retrieves assembly definition identity from given runtime assembly.\r\n    </summary>\r\n    <param name=\"assembly\">The runtime assembly.</param>\r\n    <returns>Assembly definition identity.</returns>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.FromAssemblyDefinition(Assembly)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.FromAssemblyDefinition(Assembly)\">\r\n    <summary>\r\n    Retrieves assembly definition identity from given runtime assembly.\r\n    </summary>\r\n    <param name=\"assembly\">The runtime assembly.</param>\r\n    <returns>Assembly definition identity.</returns>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public string GetDisplayName(bool fullKey = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.GetDisplayName(System.Boolean)\">\r\n    <summary>\r\n    Returns the display name of the assembly identity.\r\n    </summary>\r\n    <param name=\"fullKey\">True if the full public key should be included in the name. Otherwise public key token is used.</param>\r\n    <returns>The display name.</returns>\r\n    <remarks>\r\n    Characters ',', '=', '\"', '\\'', '\\' occuring in the simple name are escaped by backslash in the display name.\r\n    Any character '\\t' is replaced by two characters '\\' and 't',\r\n    Any character '\\n' is replaced by two characters '\\' and 'n',\r\n    Any character '\\r' is replaced by two characters '\\' and 'r',\r\n    The assembly name in the display name is enclosed in double quotes if it starts or ends with \r\n    a whitespace character (' ', '\\t', '\\r', '\\n').\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.GetDisplayName(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.GetDisplayName(System.Boolean)\">\r\n    <summary>\r\n    Returns the display name of the assembly identity.\r\n    </summary>\r\n    <param name=\"fullKey\">True if the full public key should be included in the name. Otherwise public key token is used.</param>\r\n    <returns>The display name.</returns>\r\n    <remarks>\r\n    Characters ',', '=', '\"', '\\'', '\\' occuring in the simple name are escaped by backslash in the display name.\r\n    Any character '\\t' is replaced by two characters '\\' and 't',\r\n    Any character '\\n' is replaced by two characters '\\' and 'n',\r\n    Any character '\\r' is replaced by two characters '\\' and 'r',\r\n    The assembly name in the display name is enclosed in double quotes if it starts or ends with \r\n    a whitespace character (' ', '\\t', '\\r', '\\n').\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool Equals(AssemblyIdentity obj)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Determines whether the specified instance is equal to the current instance.\r\n    </summary>\r\n    <param name=\"obj\">The object to be compared with the current instance.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(Microsoft.CodeAnalysis.AssemblyIdentity)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.Equals(Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Determines whether the specified instance is equal to the current instance.\r\n    </summary>\r\n    <param name=\"obj\">The object to be compared with the current instance.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool TryParseDisplayName(string displayName, out AssemblyIdentity identity)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.TryParseDisplayName(System.String,Microsoft.CodeAnalysis.AssemblyIdentity@)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override int GetHashCode()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.GetHashCode\">\r\n    <summary>\r\n    Returns the hash code for the current instance.\r\n    </summary>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.GetHashCode",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.GetHashCode\">\r\n    <summary>\r\n    Returns the hash code for the current instance.\r\n    </summary>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.ToString\">\r\n    <summary>\r\n    Returns the display name of the current instance.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentity.ToString",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentity.ToString\">\r\n    <summary>\r\n    Returns the display name of the current instance.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public sealed partial class AssemblyIdentity\r\n\r\n#endregion",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyIdentity\">\r\n    <summary>\r\n    Represents an identity of an assembly as defined by CLI metadata specification.\r\n    </summary>\r\n    <remarks>\r\n    May represent assembly definition or assembly reference identity.\r\n    </remarks>\r\n    <summary>\r\n    Represents an identity of an assembly as defined by CLI metadata specification.\r\n    </summary>\r\n    <remarks>\r\n    May represent assembly definition or assembly reference identity.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.AssemblyIdentity",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyIdentity\">\r\n    <summary>\r\n    Represents an identity of an assembly as defined by CLI metadata specification.\r\n    </summary>\r\n    <remarks>\r\n    May represent assembly definition or assembly reference identity.\r\n    </remarks>\r\n    <summary>\r\n    Represents an identity of an assembly as defined by CLI metadata specification.\r\n    </summary>\r\n    <remarks>\r\n    May represent assembly definition or assembly reference identity.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class AttributeData",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.AttributeData",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Compare(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares reference assembly identity with definition identity and returns their relationship.\r\n    </summary>\r\n    <param name=\"reference\">Reference identity.</param>\r\n    <param name=\"definition\">Definition identity.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Compare(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.Compare(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares reference assembly identity with definition identity and returns their relationship.\r\n    </summary>\r\n    <param name=\"reference\">Reference identity.</param>\r\n    <param name=\"definition\">Definition identity.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares assembly reference identity with definition identity.\r\n    </summary>\r\n    <param name=\"reference\">Reference assembly identity.</param>\r\n    <param name=\"definition\">Full assembly display name.</param>\r\n    <returns>True if the reference identity matches the definition identity.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares assembly reference identity with definition identity.\r\n    </summary>\r\n    <param name=\"reference\">Reference assembly identity.</param>\r\n    <param name=\"definition\">Full assembly display name.</param>\r\n    <returns>True if the reference identity matches the definition identity.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(System.String,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares assembly reference name (possibly partial) with definition identity.\r\n    </summary>\r\n    <param name=\"referenceDisplayName\">Partial or full assembly display name.</param>\r\n    <param name=\"definition\">Full assembly display name.</param>\r\n    <returns>True if the reference name matches the definition identity.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(System.String,Microsoft.CodeAnalysis.AssemblyIdentity)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AssemblyIdentityComparer.ReferenceMatchesDefinition(System.String,Microsoft.CodeAnalysis.AssemblyIdentity)\">\r\n    <summary>\r\n    Compares assembly reference name (possibly partial) with definition identity.\r\n    </summary>\r\n    <param name=\"referenceDisplayName\">Partial or full assembly display name.</param>\r\n    <param name=\"definition\">Full assembly display name.</param>\r\n    <returns>True if the reference name matches the definition identity.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public class AssemblyIdentityComparer",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyIdentityComparer\">\r\n    <summary>\r\n    Compares assembly identities. \r\n    Derived types may implement platform specific unification and portability policies.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.AssemblyIdentityComparer",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.AssemblyIdentityComparer\">\r\n    <summary>\r\n    Compares assembly identities. \r\n    Derived types may implement platform specific unification and portability policies.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static string ToDisplayString(this ImmutableArray<SymbolDisplayPart> parts)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})\">\r\n    <summary>\r\n    Converts an immutable array of <see cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayPart\"/>s to a string.\r\n    </summary>\r\n    <param name=\"parts\">The array of parts.</param>\r\n    <returns>The concatenation of the parts into a single string.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SymbolDisplayExtensions.ToDisplayString(ImmutableArray{Microsoft.CodeAnalysis.SymbolDisplayPart})\">\r\n    <summary>\r\n    Converts an immutable array of <see cref=\"T:Microsoft.CodeAnalysis.SymbolDisplayPart\"/>s to a string.\r\n    </summary>\r\n    <param name=\"parts\">The array of parts.</param>\r\n    <returns>The concatenation of the parts into a single string.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static class SymbolDisplayExtensions",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SymbolDisplayExtensions\">\r\n    <summary>\r\n    Exposes extension methods for displaying symbol descriptions.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SymbolDisplayExtensions",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SymbolDisplayExtensions\">\r\n    <summary>\r\n    Exposes extension methods for displaying symbol descriptions.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties = default (MetadataReferenceProperties), DocumentationProvider documentation = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)\">\r\n    <summary>\r\n    Creates a reference to an assembly or standalone module stored in a file.\r\n    Reads the content of the file into memory.\r\n    </summary>\r\n    <param name=\"path\">Path to the assembly file.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">An error occured while reading the file.</exception>\r\n    <remarks>\r\n    Performance considerations:\r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)\"/> \r\n    API when creating multiple references to the same file.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method eagerly reads the entire content of the file into native heap. The native memory block is released \r\n    when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage\r\n    the lifetime deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> \r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromFile(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)\">\r\n    <summary>\r\n    Creates a reference to an assembly or standalone module stored in a file.\r\n    Reads the content of the file into memory.\r\n    </summary>\r\n    <param name=\"path\">Path to the assembly file.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"path\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"path\"/> is invalid.</exception>\r\n    <exception cref=\"!:IOException\">An error occured while reading the file.</exception>\r\n    <remarks>\r\n    Performance considerations:\r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromFile(System.String)\"/> \r\n    API when creating multiple references to the same file.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method eagerly reads the entire content of the file into native heap. The native memory block is released \r\n    when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage\r\n    the lifetime deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> \r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)\">\r\n    <summary>\r\n    Creates a reference to a loaded assembly.\r\n    </summary>\r\n    <param name=\"assembly\">Path to the module file.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"properties\"/>.<see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind\"/> is not <see cref=\"F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly\"/>.</exception>\r\n    <exception cref=\"!:NotSupportedException\"><paramref name=\"assembly\"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>\r\n    <remarks>\r\n    Performance considerations:\r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> API when creating multiple references to the same assembly.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\"/> object allows for sharing data accross these references.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider)\">\r\n    <summary>\r\n    Creates a reference to a loaded assembly.\r\n    </summary>\r\n    <param name=\"assembly\">Path to the module file.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"properties\"/>.<see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.Kind\"/> is not <see cref=\"F:Microsoft.CodeAnalysis.MetadataImageKind.Assembly\"/>.</exception>\r\n    <exception cref=\"!:NotSupportedException\"><paramref name=\"assembly\"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>\r\n    <remarks>\r\n    Performance considerations:\r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromFile(System.String)\"/> API when creating multiple references to the same assembly.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.AssemblyMetadata\"/> object allows for sharing data accross these references.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public MetadataReference WithEmbedInteropTypes(bool value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.WithEmbedInteropTypes(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties = default (MetadataReferenceProperties), DocumentationProvider documentation = null, string filePath = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromStream(Stream,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a stand-alone module from data in specified stream. \r\n    Reads the content of the stream into memory and closes the stream upon return.\r\n    </summary>\r\n    <param name=\"peStream\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"peStream\"/> doesn't support read and seek operations.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:IOException\">An error occured while reading the stream.</exception>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method eagerly reads the entire content of <paramref name=\"peStream\"/> into native heap. The native memory block is released \r\n    when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage\r\n    the lifetime deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromStream(Stream,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromStream(Stream,Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a stand-alone module from data in specified stream. \r\n    Reads the content of the stream into memory and closes the stream upon return.\r\n    </summary>\r\n    <param name=\"peStream\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"peStream\"/> doesn't support read and seek operations.</exception>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peStream\"/> is null.</exception>\r\n    <exception cref=\"!:IOException\">An error occured while reading the stream.</exception>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method eagerly reads the entire content of <paramref name=\"peStream\"/> into native heap. The native memory block is released \r\n    when the resulting reference becomes unreachable and GC collects it. To decrease memory footprint of the reference and/or manage\r\n    the lifetime deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static PortableExecutableReference CreateFromImage(ImmutableArray<byte> peImage, MetadataReferenceProperties properties = default (MetadataReferenceProperties), DocumentationProvider documentation = null, string filePath = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(ImmutableArray{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a standalone module stored in memory.\r\n    </summary>\r\n    <param name=\"peImage\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method pins <paramref name=\"peImage\"/> in managed heap. The pinned memory is released \r\n    when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory \r\n    deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    </para>\r\n    <para>\r\n    The method creates a reference to a single-module assembly. To create a reference to a multi-module assembly or a stand-alone module use \r\n    <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> and <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)\"/>.\r\n    </para>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(ImmutableArray{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(ImmutableArray{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a standalone module stored in memory.\r\n    </summary>\r\n    <param name=\"peImage\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method pins <paramref name=\"peImage\"/> in managed heap. The pinned memory is released \r\n    when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory \r\n    deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    </para>\r\n    <para>\r\n    The method creates a reference to a single-module assembly. To create a reference to a multi-module assembly or a stand-alone module use \r\n    <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(ImmutableArray{System.Byte})\"/> and <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,System.String,System.String)\"/>.\r\n    </para>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public MetadataReference WithAliases(IEnumerable<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public MetadataReference WithAliases(ImmutableArray<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(ImmutableArray{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static MetadataReference CreateFromAssembly(Assembly assembly)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly)\">\r\n    <summary>\r\n    Creates a reference to a loaded assembly.\r\n    </summary>\r\n    <param name=\"assembly\">Path to the module file.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n    <exception cref=\"!:NotSupportedException\"><paramref name=\"assembly\"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromAssembly(Assembly)\">\r\n    <summary>\r\n    Creates a reference to a loaded assembly.\r\n    </summary>\r\n    <param name=\"assembly\">Path to the module file.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"assembly\"/> is null.</exception>\r\n    <exception cref=\"!:NotSupportedException\"><paramref name=\"assembly\"/> is dynamic, doesn't have a location, or the platform doesn't support reading from the location.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public MetadataReference WithProperties(MetadataReferenceProperties properties)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static PortableExecutableReference CreateFromImage(IEnumerable<byte> peImage, MetadataReferenceProperties properties = default (MetadataReferenceProperties), DocumentationProvider documentation = null, string filePath = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(IEnumerable{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a standalone module stored in memory.\r\n    </summary>\r\n    <param name=\"peImage\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(IEnumerable{System.Byte})\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IEnumerable{System.Byte})\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method makes a copy of the data and pins it. To avoid making a copy use an overload that takes an <see cref=\"!:ImmutableArray&lt;T&gt;\"/>.\r\n    The pinned memory is released when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory \r\n    deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(IEnumerable{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReference.CreateFromImage(IEnumerable{System.Byte},Microsoft.CodeAnalysis.MetadataReferenceProperties,Microsoft.CodeAnalysis.DocumentationProvider,System.String)\">\r\n    <summary>\r\n    Creates a reference to a single-module assembly or a standalone module stored in memory.\r\n    </summary>\r\n    <param name=\"peImage\">Assembly image.</param>\r\n    <param name=\"properties\">Reference properties (extern aliases, type embedding, <see cref=\"T:Microsoft.CodeAnalysis.MetadataImageKind\"/>).</param>\r\n    <param name=\"documentation\">Provides XML documentation for symbol found in the reference.</param>\r\n    <param name=\"filePath\">Optional path that describes the location of the metadata. The file doesn't need to exist on disk. The path is opaque to the compiler.</param>\r\n    <remarks>\r\n    Performance considerations: \r\n    <para>\r\n    It is recommended to use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromImage(IEnumerable{System.Byte})\"/> or <see cref=\"M:Microsoft.CodeAnalysis.ModuleMetadata.CreateFromImage(IEnumerable{System.Byte})\"/> \r\n    API when creating multiple references to the same metadata.\r\n    Reusing <see cref=\"T:Microsoft.CodeAnalysis.Metadata\"/> object to create multiple references allows for sharing data accross these references.\r\n    </para> \r\n    <para>\r\n    The method makes a copy of the data and pins it. To avoid making a copy use an overload that takes an <see cref=\"!:ImmutableArray&lt;T&gt;\"/>.\r\n    The pinned memory is released when the resulting reference becomes unreachable and GC collects it. To control the lifetime of the pinned memory \r\n    deterministically use <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.CreateFromStream(Stream,PEStreamOptions)\"/> \r\n    to create an <see cref=\"!:IDisposable\"/> metadata object and \r\n    <see cref=\"M:Microsoft.CodeAnalysis.AssemblyMetadata.GetReference(Microsoft.CodeAnalysis.DocumentationProvider,ImmutableArray{System.String},System.Boolean,System.String,System.String)\"/> to get a reference to it.\r\n    to get a reference to it.\r\n    </para>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"peImage\"/> is null.</exception>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class MetadataReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReference\">\r\n    <summary>\r\n    Represents metadata image reference.\r\n    </summary>\r\n    <remarks>\r\n    Represents a logical location of the image, not the content of the image. \r\n    The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.MetadataReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReference\">\r\n    <summary>\r\n    Represents metadata image reference.\r\n    </summary>\r\n    <remarks>\r\n    Represents a logical location of the image, not the content of the image. \r\n    The content might change in time. A snapshot is taken when the compiler queries the reference for its metadata.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public static class LanguageNames",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.LanguageNames\">\r\n    <summary>\r\n    A class that provides constants for common language names.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.LanguageNames",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.LanguageNames\">\r\n    <summary>\r\n    A class that provides constants for common language names.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxToken> ChildTokens()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens\">\r\n    <summary>\r\n    Gets a list of the direct child tokens of this node.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildTokens\">\r\n    <summary>\r\n    Gets a list of the direct child tokens of this node.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected T GetRed<T>(ref T field, int slot)where T : SyntaxNode",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetRed``1(``0@,System.Int32)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxAnnotation> GetAnnotations(IEnumerable<string> annotationKinds)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(IEnumerable{System.String})\">\r\n    <summary>\r\n    Gets all the annotations with the specified annotation kinds. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(IEnumerable{System.String})\">\r\n    <summary>\r\n    Gets all the annotations with the specified annotation kinds. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SyntaxToken FindTokenCore(int position, bool findInsideTrivia);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia.\r\n    If false finds the token whose full span (including trivia) includes the position.\r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia.\r\n    If false finds the token whose full span (including trivia) includes the position.\r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxToken GetLastToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Gets the last token of the tree rooted by this node. Skips zero-width tokens.\r\n    </summary>\r\n    <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Gets the last token of the tree rooted by this node. Skips zero-width tokens.\r\n    </summary>\r\n    <returns>The last token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract string ToFullString();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString\">\r\n    <summary>\r\n    Returns full string representation of this node including its leading and trailing trivia.\r\n    </summary>\r\n    <returns>The full string representation of this node including its leading and trailing trivia.</returns>\r\n    <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ToFullString\">\r\n    <summary>\r\n    Returns full string representation of this node including its leading and trailing trivia.\r\n    </summary>\r\n    <returns>The full string representation of this node including its leading and trailing trivia.</returns>\r\n    <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> DescendantNodes(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool EquivalentToCore(SyntaxNode other);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Determine if this node is structurally equivalent to another.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Determine if this node is structurally equivalent to another.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant trivia of this node whose span includes the supplied position.\r\n    </summary>\r\n    <param name=\"position\">The character position of the trivia relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)\r\n    includes the position.\r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTrivia(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant trivia of this node whose span includes the supplied position.\r\n    </summary>\r\n    <param name=\"position\">The character position of the trivia relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)\r\n    includes the position.\r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes and tokens (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes and tokens (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxToken GetFirstToken(bool includeZeroWidth = false, bool includeSkipped = false, bool includeDirectives = false, bool includeDocumentationComments = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Gets the first token of the tree rooted by this node. Skips zero-width tokens.\r\n    </summary>\r\n    <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Gets the first token of the tree rooted by this node. Skips zero-width tokens.\r\n    </summary>\r\n    <returns>The first token or <c>default(SyntaxToken)</c> if it doesn't exist.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool IsEquivalentTo(SyntaxNode node, bool topLevel = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)\">\r\n    <summary>\r\n    Determines if two nodes are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"node\">The node to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the nodes are equivalent if the contained nodes and\r\n    tokens declaring metadata visible symbolic information are equivalent, ignoring any\r\n    differences of nodes inside method bodies or initializer expressions, otherwise all\r\n    nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)\">\r\n    <summary>\r\n    Determines if two nodes are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"node\">The node to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the nodes are equivalent if the contained nodes and\r\n    tokens declaring metadata visible symbolic information are equivalent, ignoring any\r\n    differences of nodes inside method bodies or initializer expressions, otherwise all\r\n    nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract void SerializeTo(Stream stream, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.SerializeTo(Stream,CancellationToken)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override string ToString();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ToString\">\r\n    <summary>\r\n    Returns the string representation of this node, not including its leading and trailing trivia.\r\n    </summary>\r\n    <returns>The string representation of this node, not including its leading and trailing trivia.</returns>\r\n    <remarks>The length of the returned string is always the same as Span.Length</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ToString",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ToString\">\r\n    <summary>\r\n    Returns the string representation of this node, not including its leading and trailing trivia.\r\n    </summary>\r\n    <returns>The string representation of this node, not including its leading and trailing trivia.</returns>\r\n    <remarks>The length of the returned string is always the same as Span.Length</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool HasAnnotations(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)\">\r\n    <summary>\r\n    Determines whether this node has any annotations with the specific annotation kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(System.String)\">\r\n    <summary>\r\n    Determines whether this node has any annotations with the specific annotation kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxToken> DescendantTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of all the tokens in the full span of this node.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of all the tokens in the full span of this node.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant trivia of this node whose span includes the supplied position.\r\n    </summary>\r\n    <param name=\"position\">The character position of the trivia relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">Whether to search inside structured trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTriviaCore(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant trivia of this node whose span includes the supplied position.\r\n    </summary>\r\n    <param name=\"position\">The character position of the trivia relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">Whether to search inside structured trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all nodes with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all nodes with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxToken> GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all tokens with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all tokens with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Location GetLocation()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetLocation",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public bool HasAnnotations(IEnumerable<string> annotationKinds)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(IEnumerable{System.String})\">\r\n    <summary>\r\n    Determines whether this node has any annotations with any of the specific annotation kinds.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotations(IEnumerable{System.String})\">\r\n    <summary>\r\n    Determines whether this node has any annotations with any of the specific annotation kinds.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract void WriteTo(TextWriter writer);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(TextWriter)\">\r\n    <summary>\r\n    Writes the full text of this node to the specified <see cref=\"!:TextWriter\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(TextWriter)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.WriteTo(TextWriter)\">\r\n    <summary>\r\n    Writes the full text of this node to the specified <see cref=\"!:TextWriter\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected T GetRedAtZero<T>(ref T field)where T : SyntaxNode",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetRedAtZero``1(``0@)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all nodes and tokens with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all nodes and tokens with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)\">\r\n    <summary>\r\n    Gets all nodes and tokens with an annotation of the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String)\">\r\n    <summary>\r\n    Gets all nodes and tokens with an annotation of the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia = false, bool getInnermostNodeForTie = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Finds the node with the smallest <see cref=\"P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\"/> that contains <paramref name=\"span\"/>.\r\n    <paramref name=\"getInnermostNodeForTie\"/> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).\r\n    If <paramref name=\"getInnermostNodeForTie\"/> is true, then it returns lowest descending node encompassing the given <paramref name=\"span\"/>.\r\n    Otherwise, it returns the outermost node encompassing the given <paramref name=\"span\"/>.\r\n    </summary>\r\n    <remarks>\r\n    TODO: This should probably be reimplemented with <see cref=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)\"/>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\">This exception is thrown if <see cref=\"P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\"/> doesn't contain the given span.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindNode(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,System.Boolean)\">\r\n    <summary>\r\n    Finds the node with the smallest <see cref=\"P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\"/> that contains <paramref name=\"span\"/>.\r\n    <paramref name=\"getInnermostNodeForTie\"/> is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent).\r\n    If <paramref name=\"getInnermostNodeForTie\"/> is true, then it returns lowest descending node encompassing the given <paramref name=\"span\"/>.\r\n    Otherwise, it returns the outermost node encompassing the given <paramref name=\"span\"/>.\r\n    </summary>\r\n    <remarks>\r\n    TODO: This should probably be reimplemented with <see cref=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)\"/>\r\n    </remarks>\r\n    <exception cref=\"!:ArgumentOutOfRangeException\">This exception is thrown if <see cref=\"P:Microsoft.CodeAnalysis.SyntaxNode.FullSpan\"/> doesn't contain the given span.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool IsEquivalentTo(SyntaxNode other)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Determine whether this node is structurally equivalent to another.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Determine whether this node is structurally equivalent to another.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxTriviaList GetTrailingTrivia()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia\">\r\n    <summary>\r\n    The list of trivia that appears after this node in the source code and are attached to a token that is a\r\n    descendant of this node.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetTrailingTrivia\">\r\n    <summary>\r\n    The list of trivia that appears after this node in the source code and are attached to a token that is a\r\n    descendant of this node.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> DescendantNodesAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia = true)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)\">\r\n    <summary>\r\n    Gets a list of ancestor nodes (including this node) \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.AncestorsAndSelf(System.Boolean)\">\r\n    <summary>\r\n    Gets a list of ancestor nodes (including this node) \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(params string[] annotationKinds)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])\">\r\n    <summary>\r\n    Gets all nodes and tokens with an annotation of the specified annotation kinds.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodesAndTokens(System.String[])\">\r\n    <summary>\r\n    Gets all nodes and tokens with an annotation of the specified annotation kinds.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxToken FindToken(int position, bool findInsideTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)\r\n    includes the position.\r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindToken(System.Int32,System.Boolean)\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"findInsideTrivia\">\r\n    True to return tokens that are part of trivia. If false finds the token whose full span (including trivia)\r\n    includes the position.\r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public T CopyAnnotationsTo<T>(T node)where T : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)\">\r\n    <summary>\r\n    Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name=\"node\" />.\r\n    </summary>\r\n    <remarks>\r\n    <para>\r\n    If no annotations are copied, just returns <paramref name=\"node\" />.\r\n    </para>\r\n    <para>\r\n    It can also be used manually to preserve annotations in a more complex tree\r\n    modification, even if the type of a node changes.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.CopyAnnotationsTo``1(``0)\">\r\n    <summary>\r\n    Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on <paramref name=\"node\" />.\r\n    </summary>\r\n    <remarks>\r\n    <para>\r\n    If no annotations are copied, just returns <paramref name=\"node\" />.\r\n    </para>\r\n    <para>\r\n    It can also be used manually to preserve annotations in a more complex tree\r\n    modification, even if the type of a node changes.\r\n    </para>\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxAnnotation> GetAnnotations(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)\">\r\n    <summary>\r\n    Gets all the annotations with the specified annotation kind. \r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotations(System.String)\">\r\n    <summary>\r\n    Gets all the annotations with the specified annotation kind. \r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SyntaxToken FindTokenCore(int position, Func<SyntaxTrivia, bool> stepInto);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"stepInto\">\r\n    Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. \r\n    Pass null to skip all structured trivia.\r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FindTokenCore(System.Int32,Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})\">\r\n    <summary>\r\n    Finds a descendant token of this node whose span includes the supplied position. \r\n    </summary>\r\n    <param name=\"position\">The character position of the token relative to the beginning of the file.</param>\r\n    <param name=\"stepInto\">\r\n    Applied on every structured trivia. Return false if the tokens included in the trivia should be skipped. \r\n    Pass null to skip all structured trivia.\r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of the descendant nodes and tokens (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokensAndSelf(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of the descendant nodes and tokens (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxReference GetReference()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetReference\">\r\n    <summary>\r\n    Gets an SyntaxReference for this syntax node. CommonSyntaxReferences can be used to\r\n    regain access to a syntax node without keeping the entire tree and source text in\r\n    memory.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetReference",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetReference\">\r\n    <summary>\r\n    Gets an SyntaxReference for this syntax node. CommonSyntaxReferences can be used to\r\n    regain access to a syntax node without keeping the entire tree and source text in\r\n    memory.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool IsPartOfStructuredTrivia()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia\">\r\n    <summary>\r\n    Determines whether this node is a descendant of a structured trivia.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsPartOfStructuredTrivia\">\r\n    <summary>\r\n    Determines whether this node is a descendant of a structured trivia.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(params string[] annotationKinds)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])\">\r\n    <summary>\r\n    Gets all trivia with an annotation of the specified annotation kinds.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String[])\">\r\n    <summary>\r\n    Gets all trivia with an annotation of the specified annotation kinds.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxTriviaList GetLeadingTrivia()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia\">\r\n    <summary>\r\n    The list of trivia that appears before this node in the source code and are attached to a token that is a\r\n    descendant of this node.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetLeadingTrivia\">\r\n    <summary>\r\n    The list of trivia that appears before this node in the source code and are attached to a token that is a\r\n    descendant of this node.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> GetAnnotatedNodes(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)\">\r\n    <summary>\r\n    Gets all nodes with the specified annotation kind.\r\n    </summary>\r\n    <param name=\"annotationKind\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedNodes(System.String)\">\r\n    <summary>\r\n    Gets all nodes with the specified annotation kind.\r\n    </summary>\r\n    <param name=\"annotationKind\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(SyntaxAnnotation annotation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all trivia with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Gets all trivia with the specified annotation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes and tokens in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes and tokens in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNodeOrToken> DescendantNodesAndTokens(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of the descendant nodes and tokens in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndTokens(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of the descendant nodes and tokens in prefix document order.\r\n    </summary>\r\n    <param name=\"span\">The span the node's full span must intersect.</param>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> Ancestors(bool ascendOutOfTrivia = true)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)\">\r\n    <summary>\r\n    Gets a list of ancestor nodes\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.Ancestors(System.Boolean)\">\r\n    <summary>\r\n    Gets a list of ancestor nodes\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> DescendantNodes(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodes(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxTrivia> GetAnnotatedTrivia(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)\">\r\n    <summary>\r\n    Gets all trivia with an annotation of the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTrivia(System.String)\">\r\n    <summary>\r\n    Gets all trivia with an annotation of the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool HasAnnotation(SyntaxAnnotation annotation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Determines whether this node has the specific annotation.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.HasAnnotation(Microsoft.CodeAnalysis.SyntaxAnnotation)\">\r\n    <summary>\r\n    Determines whether this node has the specific annotation.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SourceText GetText(Encoding encoding = null, SourceHashAlgorithm checksumAlgorithm = SourceHashAlgorithm.Sha1)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetText(Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Gets the full text of this node as an new <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> instance.\r\n    </summary>\r\n    <param name=\"encoding\">\r\n    Encoding of the file that the text was read from or is going to be saved to.\r\n    <c>null</c> if the encoding is unspecified.\r\n    If the encoding is not specified the <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> isn't debuggable.\r\n    If an encoding-less <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> is written to a file a <see cref=\"!:Encoding.UTF8\"/> shall be used as a default.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"checksumAlgorithm\"/> is not supported.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetText(Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetText(Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm)\">\r\n    <summary>\r\n    Gets the full text of this node as an new <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> instance.\r\n    </summary>\r\n    <param name=\"encoding\">\r\n    Encoding of the file that the text was read from or is going to be saved to.\r\n    <c>null</c> if the encoding is unspecified.\r\n    If the encoding is not specified the <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> isn't debuggable.\r\n    If an encoding-less <see cref=\"T:Microsoft.CodeAnalysis.Text.SourceText\"/> is written to a file a <see cref=\"!:Encoding.UTF8\"/> shall be used as a default.\r\n    </param>\r\n    <param name=\"checksumAlgorithm\">\r\n    Hash algorithm to use to calculate checksum of the text that's saved to PDB.\r\n    </param>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"checksumAlgorithm\"/> is not supported.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<Diagnostic> GetDiagnostics()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the sub tree that has this node as its root.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetDiagnostics\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the sub tree that has this node as its root.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxTrivia> DescendantTrivia(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Get a list of all the trivia associated with the descendant nodes and tokens.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Get a list of all the trivia associated with the descendant nodes and tokens.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> DescendantNodesAndSelf(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantNodesAndSelf(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of descendant nodes (including this node) in prefix document order.\r\n    </summary>\r\n    <param name=\"descendIntoChildren\">An optional function that determines if the search descends into the argument node's children.</param>\r\n    <param name=\"descendIntoTrivia\">Determines if nodes that are part of structured trivia are included in the list.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxToken> GetAnnotatedTokens(string annotationKind)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)\">\r\n    <summary>\r\n    Gets all tokens with the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.GetAnnotatedTokens(System.String)\">\r\n    <summary>\r\n    Gets all tokens with the specified annotation kind.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxNode> ChildNodes()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes\">\r\n    <summary>\r\n    Gets a list of the child nodes in prefix document order.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodes\">\r\n    <summary>\r\n    Gets a list of the child nodes in prefix document order.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract SyntaxNodeOrToken ChildThatContainsPosition(int position);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxTrivia> DescendantTrivia(TextSpan span, Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Get a list of all the trivia associated with the descendant nodes and tokens.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTrivia(Microsoft.CodeAnalysis.Text.TextSpan,Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Get a list of all the trivia associated with the descendant nodes and tokens.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool IsEquivalentToCore(SyntaxNode node, bool topLevel = false);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)\">\r\n    <summary>\r\n    Determines if two nodes are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"node\">The node to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the nodes are equivalent if the contained nodes and\r\n    tokens declaring metadata visible symbolic information are equivalent, ignoring any\r\n    differences of nodes inside method bodies or initializer expressions, otherwise all\r\n    nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.IsEquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)\">\r\n    <summary>\r\n    Determines if two nodes are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"node\">The node to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the nodes are equivalent if the contained nodes and\r\n    tokens declaring metadata visible symbolic information are equivalent, ignoring any\r\n    differences of nodes inside method bodies or initializer expressions, otherwise all\r\n    nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public TNode FirstAncestorOrSelf<TNode>(Func<TNode, bool> predicate = null, bool ascendOutOfTrivia = true)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(Func{``0,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets the first node of type TNode that matches the predicate.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(Func{``0,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.FirstAncestorOrSelf``1(Func{``0,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets the first node of type TNode that matches the predicate.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public IEnumerable<SyntaxToken> DescendantTokens(Func<SyntaxNode, bool> descendIntoChildren = null, bool descendIntoTrivia = false)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of all the tokens in the span of this node.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.DescendantTokens(Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean)\">\r\n    <summary>\r\n    Gets a list of all the tokens in the span of this node.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public ChildSyntaxList ChildNodesAndTokens()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens\">\r\n    <summary>\r\n    The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNode.ChildNodesAndTokens\">\r\n    <summary>\r\n    The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract partial class SyntaxNode\r\n\r\n#endregion",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxNode\">\r\n    <summary>\r\n    Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see\r\n    cref=\"T:Microsoft.CodeAnalysis.CSharp.SyntaxNode\"/> and <see cref=\"T:Microsoft.CodeAnalysis.VisualBasic.SyntaxNode\"/>.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxNode",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxNode\">\r\n    <summary>\r\n    Represents a non-terminal node in the syntax tree. This is the language agnostic equivalent of <see\r\n    cref=\"T:Microsoft.CodeAnalysis.CSharp.SyntaxNode\"/> and <see cref=\"T:Microsoft.CodeAnalysis.VisualBasic.SyntaxNode\"/>.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.ToString",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected virtual string GetDebuggerDisplay()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.GetDebuggerDisplay",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)\">\r\n    <summary>\r\n    Creates an instance of a <see cref=\"T:Microsoft.CodeAnalysis.Location\"/> for a span in a file.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.Create(System.String,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Text.LinePositionSpan)\">\r\n    <summary>\r\n    Creates an instance of a <see cref=\"T:Microsoft.CodeAnalysis.Location\"/> for a span in a file.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object obj);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual FileLinePositionSpan GetLineSpan()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.GetLineSpan\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column.\r\n    </summary>\r\n    <returns>\r\n    <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    \r\n    Returns an invalid span (see <see cref=\"P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid\"/>) if the information is not available.\r\n    \r\n    The values are not affected by line mapping directives (#line in C# or #ExternalSource in VB).\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.GetLineSpan",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.GetLineSpan\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column.\r\n    </summary>\r\n    <returns>\r\n    <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    \r\n    Returns an invalid span (see <see cref=\"P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid\"/>) if the information is not available.\r\n    \r\n    The values are not affected by line mapping directives (#line in C# or #ExternalSource in VB).\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual FileLinePositionSpan GetMappedLineSpan()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.GetMappedLineSpan\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column after applying source line mapping directives\r\n    (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). \r\n    </summary>\r\n    <returns>\r\n    <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains file, line and column information,\r\n    or an invalid span (see <see cref=\"P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid\"/>) if not available.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.GetMappedLineSpan",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.GetMappedLineSpan\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column after applying source line mapping directives\r\n    (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). \r\n    </summary>\r\n    <returns>\r\n    <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains file, line and column information,\r\n    or an invalid span (see <see cref=\"P:Microsoft.CodeAnalysis.FileLinePositionSpan.IsValid\"/>) if not available.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.Create(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Creates an instance of a <see cref=\"T:Microsoft.CodeAnalysis.Location\"/> for a span in a <see cref=\"T:Microsoft.CodeAnalysis.SyntaxTree\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Location.Create(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Location.Create(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Creates an instance of a <see cref=\"T:Microsoft.CodeAnalysis.Location\"/> for a span in a <see cref=\"T:Microsoft.CodeAnalysis.SyntaxTree\"/>.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class Location",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Location\">\r\n    <summary>\r\n    A program location in source code.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Location",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Location\">\r\n    <summary>\r\n    A program location in source code.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class DllImportData",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DllImportData\">\r\n    <summary>\r\n    Information that describes how a method from the underlying Platform is to be invoked.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.DllImportData",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DllImportData\">\r\n    <summary>\r\n    Information that describes how a method from the underlying Platform is to be invoked.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public bool Equals(SyntaxAnnotation other)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxAnnotation.Equals(Microsoft.CodeAnalysis.SyntaxAnnotation)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override int GetHashCode()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxAnnotation.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override bool Equals(object obj)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxAnnotation.Equals(System.Object)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class SyntaxAnnotation",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxAnnotation\">\r\n    <summary>\r\n    A SynatxAnnotation is used to annotate syntax elements with additional information. \r\n    \r\n    Since syntax elements are immutable, annotating them requires creating new instances of them\r\n    with the annotations attached.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxAnnotation",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxAnnotation\">\r\n    <summary>\r\n    A SynatxAnnotation is used to annotate syntax elements with additional information. \r\n    \r\n    Since syntax elements are immutable, annotating them requires creating new instances of them\r\n    with the annotations attached.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract PortableExecutableReference GetReference(string resolvedPath, MetadataReferenceProperties properties);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReferenceProvider.GetReference(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Maps \"metadata about .NET metadata\" to <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/>. \r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <param name=\"properties\">Metadata reference properties.</param>\r\n    <returns>A <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/> corresponding to the <paramref name=\"resolvedPath\"/> and\r\n    <paramref name=\"properties\"/> parameters.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReferenceProvider.GetReference(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.MetadataReferenceProvider.GetReference(System.String,Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Maps \"metadata about .NET metadata\" to <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/>. \r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <param name=\"properties\">Metadata reference properties.</param>\r\n    <returns>A <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/> corresponding to the <paramref name=\"resolvedPath\"/> and\r\n    <paramref name=\"properties\"/> parameters.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class MetadataReferenceProvider",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReferenceProvider\">\r\n    <summary>\r\n    An extensible mechanism for providing <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/>\r\n    to services that require them.\r\n    </summary>\r\n    <remarks>Used to create <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/> when \r\n    processing interactive code directives that load .NET metadata.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.MetadataReferenceProvider",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReferenceProvider\">\r\n    <summary>\r\n    An extensible mechanism for providing <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/>\r\n    to services that require them.\r\n    </summary>\r\n    <remarks>Used to create <see cref=\"T:Microsoft.CodeAnalysis.PortableExecutableReference\"/> when \r\n    processing interactive code directives that load .NET metadata.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot TrackNodes<TRoot>(this TRoot root, params SyntaxNode[] nodes)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes being tracked.\r\n    \r\n    Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,\r\n    to get the current node corresponding to the original tracked node.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the nodes to be tracked.</param>\r\n    <param name=\"nodes\">One or more nodes that are descendants of the root node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,Microsoft.CodeAnalysis.SyntaxNode[])\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes being tracked.\r\n    \r\n    Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,\r\n    to get the current node corresponding to the original tracked node.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the nodes to be tracked.</param>\r\n    <param name=\"nodes\">One or more nodes that are descendants of the root node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithoutLeadingTrivia<TSyntax>(this TSyntax node)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia removed.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutLeadingTrivia``1(``0)\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia removed.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, SyntaxTriviaList trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTriviaList)\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot RemoveNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, SyntaxRemoveOptions options)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes removed.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node from which to remove a descendant node from.</param>\r\n    <param name=\"nodes\">The nodes to remove.</param>\r\n    <param name=\"options\">Options that determine how the nodes' trivia is treated.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxRemoveOptions)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes removed.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node from which to remove a descendant node from.</param>\r\n    <param name=\"nodes\">The nodes to remove.</param>\r\n    <param name=\"options\">Options that determine how the nodes' trivia is treated.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithoutTrailingTrivia<TSyntax>(this TSyntax node)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia removed.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithoutTrailingTrivia``1(``0)\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia removed.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified trivia replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to be replaced.</param>\r\n    <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified trivia replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to be replaced.</param>\r\n    <param name=\"newTrivia\">The new trivia to use in the new tree in place of the old trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertNodesAfter<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new nodes inserted after the specified node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"nodeInList\">The node to insert after; a descendant of the root node an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to insert into the tree immediately after the specified node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesAfter``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new nodes inserted after the specified node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"nodeInList\">The node to insert after; a descendant of the root node an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to insert into the tree immediately after the specified node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, params SyntaxTrivia[] trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia[])\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, IEnumerable<TNode> nodes)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{``0})\">\r\n    <summary>\r\n    Gets the nodes within the subtree corresponding to the original tracked nodes.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>\r\n    <param name=\"nodes\">One or more node instances originally tracked.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{``0})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{``0})\">\r\n    <summary>\r\n    Gets the nodes within the subtree corresponding to the original tracked nodes.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current nodes corresponding to the original tracked nodes.</param>\r\n    <param name=\"nodes\">One or more node instances originally tracked.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceSyntax<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes, Func<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"nodes\">The nodes to be replaced.</param>\r\n    <param name=\"computeReplacementNode\">A function that computes a replacement node for the\r\n    argument nodes. The first argument is the original node. The second argument is the same\r\n    node potentially rewritten with replaced descendants.</param>\r\n    <param name=\"tokens\">The tokens to be replaced.</param>\r\n    <param name=\"computeReplacementToken\">A function that computes a replacement token for\r\n    the argument tokens. The first argument is the original token. The second argument is\r\n    the same token potentially rewritten with replaced trivia.</param>\r\n    <param name=\"trivia\">The trivia to be replaced.</param>\r\n    <param name=\"computeReplacementTrivia\">A function that computes replacement trivia for\r\n    the specified arguments. The first argument is the original trivia. The second argument is\r\n    the same trivia with potentially rewritten sub structure.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceSyntax``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes, tokens and trivia replaced.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"nodes\">The nodes to be replaced.</param>\r\n    <param name=\"computeReplacementNode\">A function that computes a replacement node for the\r\n    argument nodes. The first argument is the original node. The second argument is the same\r\n    node potentially rewritten with replaced descendants.</param>\r\n    <param name=\"tokens\">The tokens to be replaced.</param>\r\n    <param name=\"computeReplacementToken\">A function that computes a replacement token for\r\n    the argument tokens. The first argument is the original token. The second argument is\r\n    the same token potentially rewritten with replaced trivia.</param>\r\n    <param name=\"trivia\">The trivia to be replaced.</param>\r\n    <param name=\"computeReplacementTrivia\">A function that computes replacement trivia for\r\n    the specified arguments. The first argument is the original trivia. The second argument is\r\n    the same trivia with potentially rewritten sub structure.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old token replaced with new tokens.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to be replaced; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to use in the tree in place of the specified token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old token replaced with new tokens.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to be replaced; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to use in the tree in place of the specified token.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertTriviaAfter<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new trivia inserted after the specified trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to insert after; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaAfter``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new trivia inserted after the specified trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to insert after; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to insert into the tree immediately after the specified trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, SyntaxTrivia oldTrivia, IEnumerable<SyntaxTrivia> newTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old triva replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"oldTrivia\">The trivia to be replaced; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to use in the tree in place of the specified trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old triva replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"oldTrivia\">The trivia to be replaced; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to use in the tree in place of the specified trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot RemoveNode<TRoot>(this TRoot root, SyntaxNode node, SyntaxRemoveOptions options)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified node removed.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node from which to remove a descendant node from.</param>\r\n    <param name=\"node\">The node to remove.</param>\r\n    <param name=\"options\">Options that determine how the node's trivia is treated.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.RemoveNode``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified node removed.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node from which to remove a descendant node from.</param>\r\n    <param name=\"node\">The node to remove.</param>\r\n    <param name=\"options\">Options that determine how the node's trivia is treated.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithLeadingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithLeadingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new node from this node with the leading trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot TrackNodes<TRoot>(this TRoot root, IEnumerable<SyntaxNode> nodes)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes being tracked.\r\n    \r\n    Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,\r\n    to get the current node corresponding to the original tracked node.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the nodes to be tracked.</param>\r\n    <param name=\"nodes\">One or more nodes that are descendants of the root node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.TrackNodes``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified nodes being tracked.\r\n    \r\n    Use GetCurrentNode on the subtree resulting from this operation, or any transformation of it,\r\n    to get the current node corresponding to the original tracked node.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the nodes to be tracked.</param>\r\n    <param name=\"nodes\">One or more nodes that are descendants of the root node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceNodes<TRoot, TNode>(this TRoot root, IEnumerable<TNode> nodes, Func<TNode, TNode, SyntaxNode> computeReplacementNode)where TRoot : SyntaxNode where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,IEnumerable{``1},Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the nodes being replaced.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"nodes\">The nodes to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementNode\">A function that computes a replacement node for the\r\n    argument nodes. The first argument is the original node. The second argument is the same\r\n    node potentially rewritten with replaced descendants.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,IEnumerable{``1},Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNodes``2(``0,IEnumerable{``1},Func{``1,``1,Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the nodes being replaced.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"nodes\">The nodes to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementNode\">A function that computes a replacement node for the\r\n    argument nodes. The first argument is the original node. The second argument is the same\r\n    node potentially rewritten with replaced descendants.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertTokensBefore<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new tokens inserted before the specified token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to insert before; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to insert into the tree immediately before the specified token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensBefore``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new tokens inserted before the specified token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to insert before; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to insert into the tree immediately before the specified token.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static IEnumerable<TNode> GetCurrentNodes<TNode>(this SyntaxNode root, TNode node)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)\">\r\n    <summary>\r\n    Gets the nodes within the subtree corresponding to the original tracked node.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current node corresponding to the original tracked node.</param>\r\n    <param name=\"node\">The node instance originally tracked.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNodes``1(Microsoft.CodeAnalysis.SyntaxNode,``0)\">\r\n    <summary>\r\n    Gets the nodes within the subtree corresponding to the original tracked node.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current node corresponding to the original tracked node.</param>\r\n    <param name=\"node\">The node instance originally tracked.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode NormalizeWhitespace<TNode>(this TNode node, string indentation = DefaultIndentation, bool elasticTrivia = false)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)\">\r\n    <summary>\r\n    Creates a new syntax node with all whitespace and end of line trivia replaced with\r\n    regularly formatted trivia.\r\n    </summary>\r\n    <typeparam name=\"TNode\">The type of the node.</typeparam>\r\n    <param name=\"node\">The node to format.</param>\r\n    <param name=\"indentation\">An optional sequence of whitespace characters that defines a\r\n    single level of indentation.</param>\r\n    <param name=\"elasticTrivia\">If true the replaced trivia is elastic trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.NormalizeWhitespace``1(``0,System.String,System.Boolean)\">\r\n    <summary>\r\n    Creates a new syntax node with all whitespace and end of line trivia replaced with\r\n    regularly formatted trivia.\r\n    </summary>\r\n    <typeparam name=\"TNode\">The type of the node.</typeparam>\r\n    <param name=\"node\">The node to format.</param>\r\n    <param name=\"indentation\">An optional sequence of whitespace characters that defines a\r\n    single level of indentation.</param>\r\n    <param name=\"elasticTrivia\">If true the replaced trivia is elastic trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertTokensAfter<TRoot>(this TRoot root, SyntaxToken tokenInList, IEnumerable<SyntaxToken> newTokens)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new tokens inserted after the specified token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to insert after; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to insert into the tree immediately after the specified token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTokensAfter``1(``0,Microsoft.CodeAnalysis.SyntaxToken,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new tokens inserted after the specified token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"tokenInList\">The token to insert after; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newTokens\">A sequence of tokens to insert into the tree immediately after the specified token.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode GetCurrentNode<TNode>(this SyntaxNode root, TNode node)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)\">\r\n    <summary>\r\n    Gets the node within the subtree corresponding to the original tracked node.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current node corresponding to the original tracked node.</param>\r\n    <param name=\"node\">The node instance originally tracked.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.GetCurrentNode``1(Microsoft.CodeAnalysis.SyntaxNode,``0)\">\r\n    <summary>\r\n    Gets the node within the subtree corresponding to the original tracked node.\r\n    Use TrackNodes to start tracking nodes.\r\n    </summary>\r\n    <param name=\"root\">The root of the subtree containing the current node corresponding to the original tracked node.</param>\r\n    <param name=\"node\">The node instance originally tracked.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TSyntax WithTrailingTrivia<TSyntax>(this TSyntax node, IEnumerable<SyntaxTrivia> trivia)where TSyntax : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.WithTrailingTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new node from this node with the trailing trivia replaced.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertTriviaBefore<TRoot>(this TRoot root, SyntaxTrivia trivia, IEnumerable<SyntaxTrivia> newTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new trivia inserted before the specified trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to insert before; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertTriviaBefore``1(``0,Microsoft.CodeAnalysis.SyntaxTrivia,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new trivia inserted before the specified trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to insert before; a descendant of the root node.</param>\r\n    <param name=\"newTrivia\">A sequence of trivia to insert into the tree immediately before the specified trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceTokens<TRoot>(this TRoot root, IEnumerable<SyntaxToken> tokens, Func<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"tokens\">The token to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementToken\">A function that computes a replacement token for\r\n    the argument tokens. The first argument is the original token. The second argument is\r\n    the same token potentially rewritten with replaced trivia.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTokens``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"tokens\">The token to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementToken\">A function that computes a replacement token for\r\n    the argument tokens. The first argument is the original token. The second argument is\r\n    the same token potentially rewritten with replaced trivia.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceTrivia<TRoot>(this TRoot root, IEnumerable<SyntaxTrivia> trivia, Func<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified trivia replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementTrivia\">A function that computes replacement trivia for\r\n    the specified arguments. The first argument is the original trivia. The second argument is\r\n    the same trivia with potentially rewritten sub structure.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceTrivia``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified trivia replaced with new trivia.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"trivia\">The trivia to be replaced; descendants of the root node.</param>\r\n    <param name=\"computeReplacementTrivia\">A function that computes replacement trivia for\r\n    the specified arguments. The first argument is the original trivia. The second argument is\r\n    the same trivia with potentially rewritten sub structure.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot InsertNodesBefore<TRoot>(this TRoot root, SyntaxNode nodeInList, IEnumerable<SyntaxNode> newNodes)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new nodes inserted before the specified node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"nodeInList\">The node to insert before; a descendant of the root node an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to insert into the tree immediately before the specified node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.InsertNodesBefore``1(``0,Microsoft.CodeAnalysis.SyntaxNode,IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})\">\r\n    <summary>\r\n    Creates a new tree of nodes with new nodes inserted before the specified node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"nodeInList\">The node to insert before; a descendant of the root node an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to insert into the tree immediately before the specified node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceNode<TRoot, TNode>(this TRoot root, TNode oldNode, IEnumerable<TNode> newNodes)where TRoot : SyntaxNode where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,IEnumerable{``1})\">\r\n    <summary>\r\n    Creates a new tree of nodes with specified old node replaced with a new nodes.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the replaced node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"oldNode\">The node to be replaced; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to use in the tree in place of the old node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,IEnumerable{``1})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,IEnumerable{``1})\">\r\n    <summary>\r\n    Creates a new tree of nodes with specified old node replaced with a new nodes.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the replaced node.</typeparam>\r\n    <param name=\"root\">The root of the tree of nodes.</param>\r\n    <param name=\"oldNode\">The node to be replaced; a descendant of the root node and an element of a list member.</param>\r\n    <param name=\"newNodes\">A sequence of nodes to use in the tree in place of the old node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceNode<TRoot, TNode>(this TRoot root, TNode oldNode, TNode newNode)where TRoot : SyntaxNode where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,``1)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the replaced node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"oldNode\">The node to be replaced; a descendant of the root node.</param>\r\n    <param name=\"newNode\">The new node to use in the new tree in place of the old node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,``1)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceNode``2(``0,``1,``1)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old node replaced with a new node.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <typeparam name=\"TNode\">The type of the replaced node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"oldNode\">The node to be replaced; a descendant of the root node.</param>\r\n    <param name=\"newNode\">The new node to use in the new tree in place of the old node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TRoot ReplaceToken<TRoot>(this TRoot root, SyntaxToken oldToken, SyntaxToken newToken)where TRoot : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old token replaced with a new token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"oldToken\">The token to be replaced.</param>\r\n    <param name=\"newToken\">The new token to use in the new tree in place of the old\r\n    token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxNodeExtensions.ReplaceToken``1(``0,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Creates a new tree of nodes with the specified old token replaced with a new token.\r\n    </summary>\r\n    <typeparam name=\"TRoot\">The type of the root node.</typeparam>\r\n    <param name=\"root\">The root node of the tree of nodes.</param>\r\n    <param name=\"oldToken\">The token to be replaced.</param>\r\n    <param name=\"newToken\">The new token to use in the new tree in place of the old\r\n    token.</param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static partial class SyntaxNodeExtensions",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxNodeExtensions",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract SyntaxTree WithFilePath(string path);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithFilePath(System.String)\">\r\n    <summary>\r\n    Returns a new tree whose <see cref=\"P:Microsoft.CodeAnalysis.SyntaxTree.FilePath\"/> is the specified node and other properties are copied from the current tree.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.WithFilePath(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithFilePath(System.String)\">\r\n    <summary>\r\n    Returns a new tree whose <see cref=\"P:Microsoft.CodeAnalysis.SyntaxTree.FilePath\"/> is the specified node and other properties are copied from the current tree.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IEnumerable<Diagnostic> GetDiagnostics(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the syntax tree.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(CancellationToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the syntax tree.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column after applying source line mapping directives \r\n    (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). \r\n    </summary>\r\n    <param name=\"span\">Span within the tree.</param>\r\n    <param name=\"cancellationToken\">Cancallation token.</param>\r\n    <returns>\r\n    A valid <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    \r\n    If the location path is mapped the resulting path is the path specified in the corresponding <code>#line</code>,\r\n    otherwise it's <see cref=\"P:Microsoft.CodeAnalysis.SyntaxTree.FilePath\"/>.\r\n    \r\n    A location path is considered mapped if the first <code>#line</code> directive that preceeds it and that \r\n    either specifies an explicit file path or is <code>#line default</code> exists and specifies an explicit path.\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column after applying source line mapping directives \r\n    (<code>#line</code> in C# or <code>#ExternalSource</code> in VB). \r\n    </summary>\r\n    <param name=\"span\">Span within the tree.</param>\r\n    <param name=\"cancellationToken\">Cancallation token.</param>\r\n    <returns>\r\n    A valid <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    \r\n    If the location path is mapped the resulting path is the path specified in the corresponding <code>#line</code>,\r\n    otherwise it's <see cref=\"P:Microsoft.CodeAnalysis.SyntaxTree.FilePath\"/>.\r\n    \r\n    A location path is considered mapped if the first <code>#line</code> directive that preceeds it and that \r\n    either specifies an explicit file path or is <code>#line default</code> exists and specifies an explicit path.\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxToken token);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics associated with the token and any related trivia.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics associated with the token and any related trivia.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions)\">\r\n    <summary>\r\n    Returns a new tree whose root and options are as specified and other properties are copied from the current tree.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithRootAndOptions(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions)\">\r\n    <summary>\r\n    Returns a new tree whose root and options are as specified and other properties are copied from the current tree.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract SyntaxTree WithChangedText(SourceText newText);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Create a new syntax tree based off this tree using a new source text.\r\n    \r\n    If the new source text is a minor change from the current source text an incremental\r\n    parse will occur reusing most of the current syntax tree internal data.  Otherwise, a\r\n    full parse will occur using the new source text.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)\">\r\n    <summary>\r\n    Create a new syntax tree based off this tree using a new source text.\r\n    \r\n    If the new source text is a minor change from the current source text an incremental\r\n    parse will occur reusing most of the current syntax tree internal data.  Otherwise, a\r\n    full parse will occur using the new source text.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract bool TryGetText(out SourceText text);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)\">\r\n    <summary>\r\n    Gets the syntax tree's text if it is available.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)\">\r\n    <summary>\r\n    Gets the syntax tree's text if it is available.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IList<TextChange> GetChanges(SyntaxTree oldTree);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Gets a list of text changes that when applied to the old tree produce this tree.\r\n    </summary>\r\n    <param name=\"oldTree\">The old tree.</param>\r\n    <remarks>The list of changes may be different than the original changes that produced\r\n    this tree.</remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Gets a list of text changes that when applied to the old tree produce this tree.\r\n    </summary>\r\n    <param name=\"oldTree\">The old tree.</param>\r\n    <remarks>The list of changes may be different than the original changes that produced\r\n    this tree.</remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column for a given span.\r\n    </summary>\r\n    <param name=\"span\">Span within the tree.</param>\r\n    <param name=\"cancellationToken\">Cancallation token.</param>\r\n    <returns>\r\n    A valid <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    The values are not affected by line mapping directives (<code>#line</code>).\r\n    </returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,CancellationToken)\">\r\n    <summary>\r\n    Gets the location in terms of path, line and column for a given span.\r\n    </summary>\r\n    <param name=\"span\">Span within the tree.</param>\r\n    <param name=\"cancellationToken\">Cancallation token.</param>\r\n    <returns>\r\n    A valid <see cref=\"T:Microsoft.CodeAnalysis.FileLinePositionSpan\"/> that contains path, line and column information.\r\n    The values are not affected by line mapping directives (<code>#line</code>).\r\n    </returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IList<TextSpan> GetChangedSpans(SyntaxTree syntaxTree);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Returns a list of the changed regions between this tree and the specified tree. The list is conservative for\r\n    performance reasons. It may return larger regions than what has actually changed.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)\">\r\n    <summary>\r\n    Returns a list of the changed regions between this tree and the specified tree. The list is conservative for\r\n    performance reasons. It may return larger regions than what has actually changed.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract bool IsEquivalentTo(SyntaxTree tree, bool topLevel = false);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)\">\r\n    <summary>\r\n    Determines if two trees are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"tree\">The tree to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the trees are equivalent if the contained nodes and tokens declaring\r\n    metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\r\n    or initializer expressions, otherwise all nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)\">\r\n    <summary>\r\n    Determines if two trees are the same, disregarding trivia differences.\r\n    </summary>\r\n    <param name=\"tree\">The tree to compare against.</param>\r\n    <param name=\"topLevel\"> If true then the trees are equivalent if the contained nodes and tokens declaring\r\n    metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies\r\n    or initializer expressions, otherwise all nodes and tokens must be equivalent. \r\n    </param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNode node);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the sub tree that has the specified node as its root.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in the sub tree that has the specified node as its root.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool TryGetRoot(out SyntaxNode root)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)\">\r\n    <summary>\r\n    Gets the root of the syntax tree if it is available.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.SyntaxNode@)\">\r\n    <summary>\r\n    Gets the root of the syntax tree if it is available.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Task<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree asynchronously.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsyncCore(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree asynchronously.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or\r\n    associated with the token and its related trivia. \r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or\r\n    associated with the token and its related trivia. \r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public SyntaxNode GetRoot(CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree, causing computation if necessary.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRoot(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree, causing computation if necessary.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract SyntaxReference GetReference(SyntaxNode node);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to\r\n    regain access to a syntax node without keeping the entire tree and source text in\r\n    memory.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetReference(Microsoft.CodeAnalysis.SyntaxNode)\">\r\n    <summary>\r\n    Gets a SyntaxReference for a specified syntax node. SyntaxReferences can be used to\r\n    regain access to a syntax node without keeping the entire tree and source text in\r\n    memory.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract bool HasHiddenRegions();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions\">\r\n    <summary>\r\n    Are there any hidden regions in the tree?\r\n    </summary>\r\n    <returns>True if there is at least one hidden region.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.HasHiddenRegions\">\r\n    <summary>\r\n    Are there any hidden regions in the tree?\r\n    </summary>\r\n    <returns>True if there is at least one hidden region.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Returns the visibility for the line at the given position.\r\n    </summary>\r\n    <param name=\"position\">The position to check.</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLineVisibility(System.Int32,CancellationToken)\">\r\n    <summary>\r\n    Returns the visibility for the line at the given position.\r\n    </summary>\r\n    <param name=\"position\">The position to check.</param>\r\n    <param name=\"cancellationToken\">The cancellation token.</param> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Task<SyntaxNode> GetRootAsync(CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree asynchronously.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree asynchronously.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract bool TryGetRootCore(out SyntaxNode root);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)\">\r\n    <summary>\r\n    Gets the root of the syntax tree if it is available.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.TryGetRootCore(Microsoft.CodeAnalysis.SyntaxNode@)\">\r\n    <summary>\r\n    Gets the root of the syntax tree if it is available.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public virtual Task<SourceText> GetTextAsync(CancellationToken cancellationToken = default (CancellationToken))",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets the text of the source document asynchronously.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetTextAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets the text of the source document asynchronously.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract SourceText GetText(CancellationToken cancellationToken = default (CancellationToken));",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetText(CancellationToken)\">\r\n    <summary>\r\n    Gets the text of the source document.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetText(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetText(CancellationToken)\">\r\n    <summary>\r\n    Gets the text of the source document.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract Location GetLocation(TextSpan span);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a location for the specified text span.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)\">\r\n    <summary>\r\n    Gets a location for the specified text span.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract IEnumerable<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics associated with the trivia.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)\">\r\n    <summary>\r\n    Gets a list of all the diagnostics associated with the trivia.\r\n    This method does not filter diagnostics based on #pragmas and compiler options\r\n    like nowarn, warnaserror etc.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract SyntaxNode GetRootCore(CancellationToken cancellationToken);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree, causing computation if necessary.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SyntaxTree.GetRootCore(CancellationToken)\">\r\n    <summary>\r\n    Gets the root node of the syntax tree, causing computation if necessary.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SyntaxTree",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxTree\">\r\n    <summary>\r\n    The parsed representation of a source document.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SyntaxTree",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SyntaxTree\">\r\n    <summary>\r\n    The parsed representation of a source document.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static TNode WithoutAnnotations<TNode>(this TNode node, string annotationKind)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)\">\r\n    <summary>\r\n    Creates a new node identical to this node with the annotions of the specified kind removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotationKind\">The kind of annotation to remove.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,System.String)\">\r\n    <summary>\r\n    Creates a new node identical to this node with the annotions of the specified kind removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotationKind\">The kind of annotation to remove.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode WithAdditionalAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations attached.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be added to the new node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations attached.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be added to the new node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode WithoutAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be removed from the new node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be removed from the new node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode WithAdditionalAnnotations<TNode>(this TNode node, IEnumerable<SyntaxAnnotation> annotations)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations attached.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be added to the new node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithAdditionalAnnotations``1(``0,IEnumerable{Microsoft.CodeAnalysis.SyntaxAnnotation})\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations attached.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be added to the new node.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static TNode WithoutAnnotations<TNode>(this TNode node, params SyntaxAnnotation[] annotations)where TNode : SyntaxNode",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be removed from the new node.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.AnnotationExtensions.WithoutAnnotations``1(``0,Microsoft.CodeAnalysis.SyntaxAnnotation[])\">\r\n    <summary>\r\n    Creates a new node identical to this node with the specified annotations removed.\r\n    </summary>\r\n    <param name=\"node\">Original node.</param>\r\n    <param name=\"annotations\">Annotations to be removed from the new node.</param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public static class AnnotationExtensions",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.AnnotationExtensions",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public new CompilationReference WithAliases(ImmutableArray<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(ImmutableArray{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(ImmutableArray{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new CompilationReference WithProperties(MetadataReferenceProperties properties)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithProperties(Microsoft.CodeAnalysis.MetadataReferenceProperties)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified properties, or this instance if properties haven't changed.\r\n    </summary>\r\n    <param name=\"properties\">The new properties for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Specified values not valid for this reference.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new CompilationReference WithEmbedInteropTypes(bool value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationReference.WithEmbedInteropTypes(System.Boolean)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithEmbedInteropTypes(System.Boolean)\">\r\n    <summary>\r\n    Returns an instance of the reference with specified interop types embedding.\r\n    </summary>\r\n    <param name=\"value\">The new value for <see cref=\"P:Microsoft.CodeAnalysis.MetadataReferenceProperties.EmbedInteropTypes\"/>.</param>\r\n    <exception cref=\"!:ArgumentException\">Interop types can't be embedded from modules.</exception> \r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public new CompilationReference WithAliases(IEnumerable<string> aliases)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(IEnumerable{System.String})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.CompilationReference.WithAliases(IEnumerable{System.String})\">\r\n    <summary>\r\n    Returns an instance of the reference with specified aliases.\r\n    </summary>\r\n    <param name=\"aliases\">The new aliases for the reference.</param>\r\n    <exception cref=\"!:ArgumentException\">Alias is invalid for the metadata kind.</exception> \r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class CompilationReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CompilationReference\">\r\n    <summary>\r\n    Reference to another C# or VB compilation.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.CompilationReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.CompilationReference\">\r\n    <summary>\r\n    Reference to another C# or VB compilation.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract Stream OpenRead(string resolvedPath);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.OpenRead(System.String)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content of the specified file.\r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"resolvedPath\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"resolvedPath\"/> is not a valid absolute path.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"resolvedPath\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.XmlReferenceResolver.OpenRead(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.OpenRead(System.String)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content of the specified file.\r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"resolvedPath\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"resolvedPath\"/> is not a valid absolute path.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"resolvedPath\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object other);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.XmlReferenceResolver.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.XmlReferenceResolver.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract string ResolveReference(string path, string baseFilePath);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)\">\r\n    <summary>\r\n    Resolves specified XML reference with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The reference path to resolve. May be absolute or relative path.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Path to the XML artifact, or null if the file can't be resolved.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.XmlReferenceResolver.ResolveReference(System.String,System.String)\">\r\n    <summary>\r\n    Resolves specified XML reference with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The reference path to resolve. May be absolute or relative path.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Path to the XML artifact, or null if the file can't be resolved.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class XmlReferenceResolver",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.XmlReferenceResolver\">\r\n    <summary>\r\n    Resolves references to XML documents specified in source code.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.XmlReferenceResolver",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.XmlReferenceResolver\">\r\n    <summary>\r\n    Resolves references to XML documents specified in source code.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class DataFlowAnalysis",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DataFlowAnalysis\">\r\n    <summary>\r\n    Provides information about how data flows into and out of a region. This information is\r\n    returned from a call to\r\n    <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeRegionDataFlow\" />.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.DataFlowAnalysis",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.DataFlowAnalysis\">\r\n    <summary>\r\n    Provides information about how data flows into and out of a region. This information is\r\n    returned from a call to\r\n    <see cref=\"M:Microsoft.CodeAnalysis.SemanticModel.AnalyzeRegionDataFlow\" />.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class CustomModifier\r\n\r\n#endregion",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.CustomModifier",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract Stream OpenRead(string resolvedPath);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.OpenRead(System.String)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content of the specified file.\r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"resolvedPath\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"resolvedPath\"/> is not a valid absolute path.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"resolvedPath\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SourceReferenceResolver.OpenRead(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.OpenRead(System.String)\">\r\n    <summary>\r\n    Opens a <see cref=\"!:Stream\"/> that allows reading the content of the specified file.\r\n    </summary>\r\n    <param name=\"resolvedPath\">Path returned by <see cref=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)\"/>.</param>\r\n    <exception cref=\"!:ArgumentNullException\"><paramref name=\"resolvedPath\"/> is null.</exception>\r\n    <exception cref=\"!:ArgumentException\"><paramref name=\"resolvedPath\"/> is not a valid absolute path.</exception>\r\n    <exception cref=\"!:IOException\">Error reading file <paramref name=\"resolvedPath\"/>. See <see cref=\"!:Exception.InnerException\"/> for details.</exception>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SourceReferenceResolver.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object other);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.SourceReferenceResolver.Equals(System.Object)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract string ResolveReference(string path, string baseFilePath);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)\">\r\n    <summary>\r\n    Resolves specified path with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The path to resolve. May be absolute or relative.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Normalized path, or null if the file can't be resolved.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.ResolveReference(System.String,System.String)\">\r\n    <summary>\r\n    Resolves specified path with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The path to resolve. May be absolute or relative.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Normalized path, or null if the file can't be resolved.</returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract string NormalizePath(string path, string baseFilePath);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.NormalizePath(System.String,System.String)\">\r\n    <summary>\r\n    Normalizes specified source path with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The source path to normalize. May be absolute or relative.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Normalized path, or null if <paramref name=\"path\"/> can't be normalized. The resulting path doesn't need to exist.</returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.SourceReferenceResolver.NormalizePath(System.String,System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.SourceReferenceResolver.NormalizePath(System.String,System.String)\">\r\n    <summary>\r\n    Normalizes specified source path with respect to base file path.\r\n    </summary>\r\n    <param name=\"path\">The source path to normalize. May be absolute or relative.</param>\r\n    <param name=\"baseFilePath\">Path of the source file that contains the <paramref name=\"path\"/> (may also be relative), or null if not available.</param>\r\n    <returns>Normalized path, or null if <paramref name=\"path\"/> can't be normalized. The resulting path doesn't need to exist.</returns>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class SourceReferenceResolver",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SourceReferenceResolver\">\r\n    <summary>\r\n    Resolves references to source documents specified in the source.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.SourceReferenceResolver",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.SourceReferenceResolver\">\r\n    <summary>\r\n    Resolves references to source documents specified in the source.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract string ResolveReference(string reference, string baseFilePath);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReferenceResolver.ResolveReference(System.String,System.String)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override int GetHashCode();",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReferenceResolver.GetHashCode",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract override bool Equals(object other);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.MetadataReferenceResolver.Equals(System.Object)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class MetadataReferenceResolver",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReferenceResolver\">\r\n    <summary>\r\n    Resolves references to metadata specified in the source (#r directives).\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.MetadataReferenceResolver",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.MetadataReferenceResolver\">\r\n    <summary>\r\n    Resolves references to metadata specified in the source (#r directives).\r\n    </summary>\r\n</member>\r\n"
        }
      ],
      "Id": "N:Microsoft.CodeAnalysis",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.Cci",
      "XmlDocumentation": ""
    },
    {
      "Classes": [
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override ImmutableArray<SyntaxNodeAnalyzerAction<TLanguageKindEnum>> GetSyntaxNodeActions<TLanguageKindEnum>()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.GetSyntaxNodeActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override bool HasCodeBlockStartActions<TLanguageKindEnum>()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.HasCodeBlockStartActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.GetAnalyzerActions(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override ImmutableArray<CodeBlockEndAnalyzerAction<TLanguageKindEnum>> GetCodeBlockEndActions<TLanguageKindEnum>()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.GetCodeBlockEndActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override ImmutableArray<CodeBlockStartAnalyzerAction<TLanguageKindEnum>> GetCodeBlockStartActions<TLanguageKindEnum>()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.GetCodeBlockStartActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override bool HasCodeBlockEndActions<TLanguageKindEnum>()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope.HasCodeBlockEndActions``1",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class HostCompilationStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for **setting up** @T:Microsoft.CodeAnalysis.Compilation analyzers for a compilation, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for **setting up** @T:Microsoft.CodeAnalysis.Compilation analyzers for a compilation, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public void RegisterSyntaxNodeAction(DiagnosticAnalyzer analyzer, Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCodeBlockStartAnalysisScope`1.RegisterSyntaxNodeAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},`0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterCodeBlockEndAction(DiagnosticAnalyzer analyzer, Action<CodeBlockEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCodeBlockStartAnalysisScope`1.RegisterCodeBlockEndAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class HostCodeBlockStartAnalysisScope<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCodeBlockStartAnalysisScope`1",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostCodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterSyntaxTreeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCodeBlockEndAction<TLanguageKindEnum>(Action<CodeBlockEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterCodeBlockEndAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCompilationStartAction(Action<CompilationStartAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterCompilationStartAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCompilationEndAction(Action<CompilationEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterCompilationEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterSymbolAction(Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterCodeBlockStartAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterSyntaxNodeAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope.RegisterSemanticModelAction(Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class AnalyzerSessionStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerSessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public void RegisterSyntaxTreeAction(DiagnosticAnalyzer analyzer, Action<SyntaxTreeAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterSyntaxTreeAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterSymbolAction(DiagnosticAnalyzer analyzer, Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterSymbolAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.GetAnalyzerActions(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterCodeBlockEndAction<TLanguageKindEnum>(DiagnosticAnalyzer analyzer, Action<CodeBlockEndAnalysisContext> action)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterCodeBlockEndAction``1(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterCompilationEndAction(DiagnosticAnalyzer analyzer, Action<CompilationEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterCompilationEndAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.CompilationEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual bool HasCodeBlockStartActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.HasCodeBlockStartActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual bool HasCodeBlockEndActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.HasCodeBlockEndActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterCodeBlockStartAction<TLanguageKindEnum>(DiagnosticAnalyzer analyzer, Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterCodeBlockStartAction``1(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual ImmutableArray<SyntaxNodeAnalyzerAction<TLanguageKindEnum>> GetSyntaxNodeActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.GetSyntaxNodeActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual ImmutableArray<CodeBlockEndAnalyzerAction<TLanguageKindEnum>> GetCodeBlockEndActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.GetCodeBlockEndActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterSemanticModelAction(DiagnosticAnalyzer analyzer, Action<SemanticModelAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterSemanticModelAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected AnalyzerActions GetOrCreateAnalyzerActions(DiagnosticAnalyzer analyzer)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.GetOrCreateAnalyzerActions(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void RegisterSyntaxNodeAction<TLanguageKindEnum>(DiagnosticAnalyzer analyzer, Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.RegisterSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public virtual ImmutableArray<CodeBlockStartAnalyzerAction<TLanguageKindEnum>> GetCodeBlockStartActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope.GetCodeBlockStartActions``1",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class HostAnalysisScope",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostAnalysisScope",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class SyntaxTreeAnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxTreeAnalyzerAction",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public ImmutableArray<CodeBlockEndAnalyzerAction<TLanguageKindEnum>> GetCodeBlockEndActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.GetCodeBlockEndActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddCodeBlockStartAction<TLanguageKindEnum>(CodeBlockStartAnalyzerAction<TLanguageKindEnum> action)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddCodeBlockStartAction``1(Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockStartAnalyzerAction{``0})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddCodeBlockEndAction<TLanguageKindEnum>(CodeBlockEndAnalyzerAction<TLanguageKindEnum> action)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddCodeBlockEndAction``1(Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockEndAnalyzerAction{``0})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddSyntaxNodeAction<TLanguageKindEnum>(SyntaxNodeAnalyzerAction<TLanguageKindEnum> action)where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddSyntaxNodeAction``1(Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{``0})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<SyntaxNodeAnalyzerAction<TLanguageKindEnum>> GetSyntaxNodeActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.GetSyntaxNodeActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public AnalyzerActions Append(AnalyzerActions otherActions)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.Append(Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddCompilationStartAction(CompilationStartAnalyzerAction action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddCompilationStartAction(Microsoft.CodeAnalysis.Diagnostics.Internal.CompilationStartAnalyzerAction)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddSymbolAction(SymbolAnalyzerAction action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddSymbolAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SymbolAnalyzerAction)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddSemanticModelAction(SemanticModelAnalyzerAction action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddSemanticModelAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SemanticModelAnalyzerAction)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public ImmutableArray<CodeBlockStartAnalyzerAction<TLanguageKindEnum>> GetCodeBlockStartActions<TLanguageKindEnum>()where TLanguageKindEnum : struct",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.GetCodeBlockStartActions``1",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddSyntaxTreeAction(SyntaxTreeAnalyzerAction action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddSyntaxTreeAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxTreeAnalyzerAction)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void AddCompilationEndAction(CompilationEndAnalyzerAction action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions.AddCompilationEndAction(Microsoft.CodeAnalysis.Diagnostics.Internal.CompilationEndAnalyzerAction)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class AnalyzerActions",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions\">\r\n    <summary>\r\n    Actions registered by a particular analyzer.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerActions\">\r\n    <summary>\r\n    Actions registered by a particular analyzer.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class CodeBlockStartAnalyzerAction<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockStartAnalyzerAction`1",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterSymbolAction(Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterSyntaxTreeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterSyntaxNodeAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterCodeBlockStartAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCodeBlockEndAction<TLanguageKindEnum>(Action<CodeBlockEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterCodeBlockEndAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterSemanticModelAction(Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCompilationEndAction(Action<CompilationEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope.RegisterCompilationEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationEndAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class AnalyzerCompilationStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for a compilation, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for a compilation, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class CompilationStartAnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.CompilationStartAnalyzerAction",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public abstract class AnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerAction",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class CompilationEndAnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.CompilationEndAnalyzerAction",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class SyntaxNodeAnalyzerAction<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction`1",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCodeBlockStartAnalysisScope`1.RegisterSyntaxNodeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},`0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override void RegisterCodeBlockEndAction(Action<CodeBlockEndAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCodeBlockStartAnalysisScope`1.RegisterCodeBlockEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class AnalyzerCodeBlockStartAnalysisScope<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCodeBlockStartAnalysisScope`1",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.AnalyzerCodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block, automatically associating actions with analyzers.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public void RegisterCompilationStartAction(DiagnosticAnalyzer analyzer, Action<CompilationStartAnalysisContext> action)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.Internal.HostSessionStartAnalysisScope.RegisterCompilationStartAction(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class HostSessionStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostSessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostSessionStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.Internal.HostSessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session, capable of retrieving the actions.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class SymbolAnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.SymbolAnalyzerAction",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class CodeBlockEndAnalyzerAction<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockEndAnalyzerAction`1",
          "XmlDocumentation": ""
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class SemanticModelAnalyzerAction",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.Internal.SemanticModelAnalyzerAction",
          "XmlDocumentation": ""
        }
      ],
      "Id": "N:Microsoft.CodeAnalysis.Diagnostics.Internal",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.SymbolDisplay",
      "XmlDocumentation": ""
    },
    {
      "Classes": [
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract void RegisterSyntaxNodeAction(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisScope`1.RegisterSyntaxNodeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},`0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCodeBlockEndAction(Action<CodeBlockEndAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisScope`1.RegisterCodeBlockEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class CodeBlockStartAnalysisScope<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisScope`1",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisScope`1\">\r\n    <summary>\r\n    Scope for setting up analyzers for a code block.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference.GetAnalyzersForAllLanguages",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference.GetAnalyzers(System.String)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class AnalyzerImageReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference\">\r\n    <summary>\r\n    Represents an in-memory analyzer reference image.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference\">\r\n    <summary>\r\n    Represents an in-memory analyzer reference image.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent.ToString",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public SemanticModel SemanticModel(SyntaxReference reference)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent.SemanticModel(Microsoft.CodeAnalysis.SyntaxReference)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "override public void FlushCache()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent.FlushCache",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class SymbolDeclaredCompilationEvent",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent\">\r\n    <summary>\r\n    An event for each declaration in the program (namespace, type, method, field, parameter, etc).\r\n    Note that some symbols may have multiple declarations (namespaces, partial types) and may therefore\r\n    have multiple events.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent\">\r\n    <summary>\r\n    An event for each declaration in the program (namespace, type, method, field, parameter, etc).\r\n    Note that some symbols may have multiple declarations (namespaces, partial types) and may therefore\r\n    have multiple events.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference.GetAnalyzersForAllLanguages",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public override ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference.GetAnalyzers(System.String)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class UnresolvedAnalyzerReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference\">\r\n    <summary>\r\n    Represents an analyzer reference that can't be resolved.\r\n    </summary>\r\n    <remarks>\r\n    For error reporting only, can't be used to reference an analyzer assembly.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference\">\r\n    <summary>\r\n    Represents an analyzer reference that can't be resolved.\r\n    </summary>\r\n    <remarks>\r\n    For error reporting only, can't be used to reference an analyzer assembly.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterSyntaxNodeAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCompilationStartAction(Action<CompilationStartAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterCompilationStartAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterSyntaxTreeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterSymbolAction(Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterSemanticModelAction(Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCodeBlockEndAction<TLanguageKindEnum>(Action<CodeBlockEndAnalysisContext> action)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterCodeBlockEndAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCompilationEndAction(Action<CompilationEndAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterCompilationEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope.RegisterCodeBlockStartAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class SessionStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.SessionStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for an entire session.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract void RegisterCompilationEndAction(Action<CompilationEndAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterCompilationEndAction(Action{Microsoft.CodeAnalysis.Diagnostics.CompilationEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSyntaxTreeAction(Action<SyntaxTreeAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterSyntaxTreeAction(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCodeBlockEndAction<TLanguageKindEnum>(Action<CodeBlockEndAnalysisContext> action)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterCodeBlockEndAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockEndAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSemanticModelAction(Action<SemanticModelAnalysisContext> action);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterSemanticModelAction(Action{Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSymbolAction(Action<SymbolAnalysisContext> action, params SymbolKind[] symbolKinds);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterSymbolAction(Action{Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext},Microsoft.CodeAnalysis.SymbolKind[])",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterCodeBlockStartAction<TLanguageKindEnum>(Action<CodeBlockStartAnalysisContext<TLanguageKindEnum>> action)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterCodeBlockStartAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext{``0}})",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public abstract void RegisterSyntaxNodeAction<TLanguageKindEnum>(Action<SyntaxNodeAnalysisContext> action, params TLanguageKindEnum[] syntaxKinds)where TLanguageKindEnum : struct;",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope.RegisterSyntaxNodeAction``1(Action{Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext},``0[])",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class CompilationStartAnalysisScope",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for a compilation.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisScope\">\r\n    <summary>\r\n    Scope for setting up analyzers for a compilation.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public new void Dispose()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.Dispose",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static void ExecuteSyntaxNodeAction(SyntaxNodeAnalyzerAction<TLanguageKindEnum> syntaxNodeAction, SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions analyzerOptions, Action<Diagnostic> addDiagnostic, Func<Exception, DiagnosticAnalyzer, bool> continueOnAnalyzerException, CancellationToken cancellationToken)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteSyntaxNodeAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},CancellationToken)\">\r\n    <summary>\r\n    Executes the given syntax node action on the given syntax node.\r\n    </summary>\r\n    <param name=\"syntaxNodeAction\">Action to execute.</param>\r\n    <param name=\"node\">Syntax node to be analyzed.</param>\r\n    <param name=\"semanticModel\">SemanticModel to be used in the analysis.</param>\r\n    <param name=\"analyzerOptions\">Analyzer options.</param>\r\n    <param name=\"addDiagnostic\">Delegate to add diagnostics.</param>\r\n    <param name=\"continueOnAnalyzerException\">Predicate to decide if exceptions from the action should be handled or not.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteSyntaxNodeAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteSyntaxNodeAction(Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},CancellationToken)\">\r\n    <summary>\r\n    Executes the given syntax node action on the given syntax node.\r\n    </summary>\r\n    <param name=\"syntaxNodeAction\">Action to execute.</param>\r\n    <param name=\"node\">Syntax node to be analyzed.</param>\r\n    <param name=\"semanticModel\">SemanticModel to be used in the analysis.</param>\r\n    <param name=\"analyzerOptions\">Analyzer options.</param>\r\n    <param name=\"addDiagnostic\">Delegate to add diagnostics.</param>\r\n    <param name=\"continueOnAnalyzerException\">Predicate to decide if exceptions from the action should be handled or not.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected override async Task AnalyzeDeclaringReferenceAsync(SymbolDeclaredCompilationEvent symbolEvent, SyntaxReference decl, Action<Diagnostic> reportDiagnostic, CancellationToken cancellationToken)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.AnalyzeDeclaringReferenceAsync(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.SyntaxReference,Action{Microsoft.CodeAnalysis.Diagnostic},CancellationToken)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static void ExecuteCodeBlockActions(IEnumerable<CodeBlockStartAnalyzerAction<TLanguageKindEnum>> codeBlockStartedAnalyzers, IEnumerable<CodeBlockEndAnalyzerAction<TLanguageKindEnum>> codeBlockEndedAnalyzers, IEnumerable<DeclarationInfo> declarationsInNode, SemanticModel semanticModel, AnalyzerOptions analyzerOptions, Action<Diagnostic> addDiagnostic, Func<Exception, DiagnosticAnalyzer, bool> continueOnAnalyzerException, Func<SyntaxNode, TLanguageKindEnum> getKind, CancellationToken cancellationToken, Func<SyntaxNodeAnalyzerAction<TLanguageKindEnum>, IEnumerable<TLanguageKindEnum>> getAnalyzerKindsOfInterest = null)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteCodeBlockActions(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockStartAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockEndAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.DeclarationInfo},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},Func{Microsoft.CodeAnalysis.SyntaxNode,`0},CancellationToken,Func{Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},IEnumerable{`0}})\">\r\n    <summary>\r\n    Executes the given code block actions on all the executable code blocks for each declaration info in <paramref name=\"declarationsInNode\"/>.\r\n    </summary>\r\n    <param name=\"codeBlockStartedAnalyzers\">Code block analyzer factories.</param>\r\n    <param name=\"codeBlockEndedAnalyzers\">Stateless code block analyzers.</param>\r\n    <param name=\"declarationsInNode\">Declarations to be analyzed.</param>\r\n    <param name=\"semanticModel\">SemanticModel to be shared amongst all actions.</param>\r\n    <param name=\"analyzerOptions\">Analyzer options.</param>\r\n    <param name=\"addDiagnostic\">Delegate to add diagnostics.</param>\r\n    <param name=\"continueOnAnalyzerException\">Predicate to decide if exceptions from any action should be handled or not.</param>\r\n    <param name=\"getKind\">Delegate to compute language specific syntax kind for a syntax node.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n    <param name=\"getAnalyzerKindsOfInterest\">Optional delegate to return cached syntax kinds.\r\n    If null, then this property is explicitly invoked by the driver to compute syntax kinds of interest.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteCodeBlockActions(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockStartAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockEndAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.DeclarationInfo},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},Func{Microsoft.CodeAnalysis.SyntaxNode,`0},CancellationToken,Func{Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},IEnumerable{`0}})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1.ExecuteCodeBlockActions(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockStartAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.Diagnostics.Internal.CodeBlockEndAnalyzerAction{`0}},IEnumerable{Microsoft.CodeAnalysis.DeclarationInfo},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},Func{Microsoft.CodeAnalysis.SyntaxNode,`0},CancellationToken,Func{Microsoft.CodeAnalysis.Diagnostics.Internal.SyntaxNodeAnalyzerAction{`0},IEnumerable{`0}})\">\r\n    <summary>\r\n    Executes the given code block actions on all the executable code blocks for each declaration info in <paramref name=\"declarationsInNode\"/>.\r\n    </summary>\r\n    <param name=\"codeBlockStartedAnalyzers\">Code block analyzer factories.</param>\r\n    <param name=\"codeBlockEndedAnalyzers\">Stateless code block analyzers.</param>\r\n    <param name=\"declarationsInNode\">Declarations to be analyzed.</param>\r\n    <param name=\"semanticModel\">SemanticModel to be shared amongst all actions.</param>\r\n    <param name=\"analyzerOptions\">Analyzer options.</param>\r\n    <param name=\"addDiagnostic\">Delegate to add diagnostics.</param>\r\n    <param name=\"continueOnAnalyzerException\">Predicate to decide if exceptions from any action should be handled or not.</param>\r\n    <param name=\"getKind\">Delegate to compute language specific syntax kind for a syntax node.</param>\r\n    <param name=\"cancellationToken\">Cancellation token.</param>\r\n    <param name=\"getAnalyzerKindsOfInterest\">Optional delegate to return cached syntax kinds.\r\n    If null, then this property is explicitly invoked by the driver to compute syntax kinds of interest.</param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public class AnalyzerDriver<TLanguageKindEnum>\r\n    where TLanguageKindEnum : struct",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1\">\r\n    <summary>\r\n    Driver to execute diagnostic analyzers for a given compilation.\r\n    It uses a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\"/> of <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/>s to drive its analysis.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1\">\r\n    <summary>\r\n    Driver to execute diagnostic analyzers for a given compilation.\r\n    It uses a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\"/> of <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/>s to drive its analysis.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract void Initialize(AnalysisContext context);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)\">\r\n    <summary>\r\n    Called once at session start to register actions in the analysis context.\r\n    </summary>\r\n    <param name=\"context\"></param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer.Initialize(Microsoft.CodeAnalysis.Diagnostics.AnalysisContext)\">\r\n    <summary>\r\n    Called once at session start to register actions in the analysis context.\r\n    </summary>\r\n    <param name=\"context\"></param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class DiagnosticAnalyzer",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer\">\r\n    <summary>\r\n    The base type for diagnostic analyzers.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer\">\r\n    <summary>\r\n    The base type for diagnostic analyzers.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzersForAllLanguages\">\r\n    <summary>\r\n    Gets all the diagnostic analyzers defined in this assembly reference, irrespective of the language supported by the analyzer.\r\n    Use this method only if you need all the analyzers defined in the assembly, without a language context.\r\n    In most instances, either the analyzer reference is associated with a project or is being queried for analyzers in a particular language context.\r\n    If so, use <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)\"/> method.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzersForAllLanguages",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzersForAllLanguages\">\r\n    <summary>\r\n    Gets all the diagnostic analyzers defined in this assembly reference, irrespective of the language supported by the analyzer.\r\n    Use this method only if you need all the analyzers defined in the assembly, without a language context.\r\n    In most instances, either the analyzer reference is associated with a project or is being queried for analyzers in a particular language context.\r\n    If so, use <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)\"/> method.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public abstract ImmutableArray<DiagnosticAnalyzer> GetAnalyzers(string language);",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)\">\r\n    <summary>\r\n    Gets all the diagnostic analyzers defined in this assembly reference for the given <paramref name=\"language\"/>.\r\n    </summary>\r\n    <param name=\"language\">Language name.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference.GetAnalyzers(System.String)\">\r\n    <summary>\r\n    Gets all the diagnostic analyzers defined in this assembly reference for the given <paramref name=\"language\"/>.\r\n    </summary>\r\n    <param name=\"language\">Language name.</param>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class AnalyzerReference",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference\">\r\n    <summary>\r\n    Represents an analyzer assembly reference that contains diagnostic analyzers.\r\n    </summary>\r\n    <remarks>\r\n    Represents a logical location of the analyzer reference, not the content of the reference. \r\n    The content might change in time. A snapshot is taken when the compiler queries the reference for its analyzers.\r\n    </remarks>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference\">\r\n    <summary>\r\n    Represents an analyzer assembly reference that contains diagnostic analyzers.\r\n    </summary>\r\n    <remarks>\r\n    Represents a logical location of the analyzer reference, not the content of the reference. \r\n    The content might change in time. A snapshot is taken when the compiler queries the reference for its analyzers.\r\n    </remarks>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class DiagnosticAnalyzerAttribute",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute\">\r\n    <summary>\r\n    Place this attribute onto a type to cause it to be considered a diagnostic analyzer.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute\">\r\n    <summary>\r\n    Place this attribute onto a type to cause it to be considered a diagnostic analyzer.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent.ToString",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class CompilationCompletedEvent",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent\">\r\n    <summary>\r\n    The last event placed into a compilation's event queue.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent\">\r\n    <summary>\r\n    The last event placed into a compilation's event queue.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public virtual void FlushCache()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.FlushCache\">\r\n    <summary>\r\n    Flush any cached data in this <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/> to minimize space usage (at the possible expense of time later).\r\n    The principal effect of this is to free cached information on events that have a <see cref=\"T:Microsoft.CodeAnalysis.SemanticModel\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.FlushCache",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent.FlushCache\">\r\n    <summary>\r\n    Flush any cached data in this <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/> to minimize space usage (at the possible expense of time later).\r\n    The principal effect of this is to free cached information on events that have a <see cref=\"T:Microsoft.CodeAnalysis.SemanticModel\"/>.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public abstract class CompilationEvent",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "protected static void ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action<Diagnostic> addDiagnostic, Func<Exception, DiagnosticAnalyzer, bool> continueOnAnalyzerException, CancellationToken cancellationToken, Action analyze)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.ExecuteAndCatchIfThrows(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Action{Microsoft.CodeAnalysis.Diagnostic},Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean},CancellationToken,Action)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public async Task<ImmutableArray<Diagnostic>> GetDiagnosticsAsync()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnosticsAsync\">\r\n    <summary>\r\n    Returns all diagnostics computed by the analyzers since the last time this was invoked.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnosticsAsync",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetDiagnosticsAsync\">\r\n    <summary>\r\n    Returns all diagnostics computed by the analyzers since the last time this was invoked.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Func<Exception, DiagnosticAnalyzer, bool> continueOnAnalyzerException)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean})\">\r\n    <summary>\r\n    Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.\r\n    <paramref name=\"continueOnAnalyzerException\"/> says whether the caller would like the exception thrown by the analyzers to be handled or not. If true - Handles ; False - Not handled.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.IsDiagnosticAnalyzerSuppressed(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Microsoft.CodeAnalysis.CompilationOptions,Func{Exception,Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,System.Boolean})\">\r\n    <summary>\r\n    Returns true if all the diagnostics that can be produced by this analyzer are suppressed through options.\r\n    <paramref name=\"continueOnAnalyzerException\"/> says whether the caller would like the exception thrown by the analyzers to be handled or not. If true - Handles ; False - Not handled.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public async Task WhenCompletedAsync()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenCompletedAsync\">\r\n    <summary>\r\n    Return a task that completes when the driver is done producing diagnostics.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenCompletedAsync",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.WhenCompletedAsync\">\r\n    <summary>\r\n    Return a task that completes when the driver is done producing diagnostics.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static AnalyzerDriver Create(Compilation compilation, ImmutableArray<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, out Compilation newCompilation, CancellationToken cancellationToken)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Create(Microsoft.CodeAnalysis.Compilation,ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.Compilation@,CancellationToken)\">\r\n    <summary>\r\n    Create an <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver\"/> and attach it to the given compilation. \r\n    </summary>\r\n    <param name=\"compilation\">The compilation to which the new driver should be attached.</param>\r\n    <param name=\"analyzers\">The set of analyzers to include in the analysis.</param>\r\n    <param name=\"options\">Options that are passed to analyzers.</param>\r\n    <param name=\"newCompilation\">The new compilation with the analyzer driver attached.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to abort analysis.</param>\r\n    <returns>A newly created analyzer driver</returns>\r\n    <remarks>\r\n    Note that since a compilation is immutable, the act of creating a driver and attaching it produces\r\n    a new compilation. Any further actions on the compilation should use the new compilation.\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Create(Microsoft.CodeAnalysis.Compilation,ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.Compilation@,CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Create(Microsoft.CodeAnalysis.Compilation,ImmutableArray{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer},Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions,Microsoft.CodeAnalysis.Compilation@,CancellationToken)\">\r\n    <summary>\r\n    Create an <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver\"/> and attach it to the given compilation. \r\n    </summary>\r\n    <param name=\"compilation\">The compilation to which the new driver should be attached.</param>\r\n    <param name=\"analyzers\">The set of analyzers to include in the analysis.</param>\r\n    <param name=\"options\">Options that are passed to analyzers.</param>\r\n    <param name=\"newCompilation\">The new compilation with the analyzer driver attached.</param>\r\n    <param name=\"cancellationToken\">A cancellation token that can be used to abort analysis.</param>\r\n    <returns>A newly created analyzer driver</returns>\r\n    <remarks>\r\n    Note that since a compilation is immutable, the act of creating a driver and attaching it produces\r\n    a new compilation. Any further actions on the compilation should use the new compilation.\r\n    </remarks>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public static IEnumerable<Diagnostic> GetEffectiveDiagnostics(IEnumerable<Diagnostic> diagnostics, Compilation compilation)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetEffectiveDiagnostics(IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)\">\r\n    <summary>\r\n    Given a set of compiler or <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer\"/> generated <paramref name=\"diagnostics\"/>, returns the effective diagnostics after applying the below filters:\r\n    1) <see cref=\"P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions\"/> specified for the given <paramref name=\"compilation\"/>.\r\n    2) <see cref=\"P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption\"/> specified for the given <paramref name=\"compilation\"/>.\r\n    3) Diagnostic suppression through applied <see cref=\"!:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute\"/>.\r\n    4) Pragma directives for the given <paramref name=\"compilation\"/>.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetEffectiveDiagnostics(IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetEffectiveDiagnostics(IEnumerable{Microsoft.CodeAnalysis.Diagnostic},Microsoft.CodeAnalysis.Compilation)\">\r\n    <summary>\r\n    Given a set of compiler or <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer\"/> generated <paramref name=\"diagnostics\"/>, returns the effective diagnostics after applying the below filters:\r\n    1) <see cref=\"P:Microsoft.CodeAnalysis.CompilationOptions.SpecificDiagnosticOptions\"/> specified for the given <paramref name=\"compilation\"/>.\r\n    2) <see cref=\"P:Microsoft.CodeAnalysis.CompilationOptions.GeneralDiagnosticOption\"/> specified for the given <paramref name=\"compilation\"/>.\r\n    3) Diagnostic suppression through applied <see cref=\"!:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute\"/>.\r\n    4) Pragma directives for the given <paramref name=\"compilation\"/>.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public void Dispose()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.Dispose",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public static HostSessionStartAnalysisScope GetSessionAnalysisScope(IEnumerable<DiagnosticAnalyzer> analyzers)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetSessionAnalysisScope(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})\">\r\n    <summary>\r\n    Create the initial analysis scope from a set of available analyzers.\r\n    </summary>\r\n    <param name=\"analyzers\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetSessionAnalysisScope(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetSessionAnalysisScope(IEnumerable{Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer})\">\r\n    <summary>\r\n    Create the initial analysis scope from a set of available analyzers.\r\n    </summary>\r\n    <param name=\"analyzers\"></param>\r\n    <returns></returns>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "protected abstract Task AnalyzeDeclaringReferenceAsync(SymbolDeclaredCompilationEvent symbolEvent, SyntaxReference decl, Action<Diagnostic> addDiagnostic, CancellationToken cancellationToken);",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.AnalyzeDeclaringReferenceAsync(Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent,Microsoft.CodeAnalysis.SyntaxReference,Action{Microsoft.CodeAnalysis.Diagnostic},CancellationToken)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "protected static Diagnostic GetAnalyzerDiagnostic(DiagnosticAnalyzer analyzer, Exception e)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver.GetAnalyzerDiagnostic(Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer,Exception)",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public abstract class AnalyzerDriver",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver\">\r\n    <summary>\r\n    Driver to execute diagnostic analyzers for a given compilation.\r\n    It uses a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\"/> of <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/>s to drive its analysis.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver\">\r\n    <summary>\r\n    Driver to execute diagnostic analyzers for a given compilation.\r\n    It uses a <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\"/> of <see cref=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationEvent\"/>s to drive its analysis.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent.ToString",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "override public void FlushCache()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent.FlushCache",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class CompilationUnitCompletedEvent",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent.ToString",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public sealed class CompilationStartedEvent",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent\">\r\n    <summary>\r\n    The first event placed into a compilation's event queue.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent\">\r\n    <summary>\r\n    The first event placed into a compilation's event queue.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public override string ToString()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.ToString",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void Complete()",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete\">\r\n    <summary>\r\n    Signals that no further elements will be enqueued.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete\">\r\n    <summary>\r\n    Signals that no further elements will be enqueued.\r\n    </summary>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public bool TryDequeue(out TElement d)",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.TryDequeue(`0@)",
              "XmlDocumentation": ""
            },
            {
              "Syntax": {
                "Content": "public void SetException(Exception exception)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(Exception)\">\r\n    <summary>\r\n    Set the queue to an exception state. Once this has been done, every\r\n    Dequeue operation will throw this exception.\r\n    </summary>\r\n    <param name=\"exception\">The exception to be associated with this queue.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(Exception)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(Exception)\">\r\n    <summary>\r\n    Set the queue to an exception state. Once this has been done, every\r\n    Dequeue operation will throw this exception.\r\n    </summary>\r\n    <param name=\"exception\">The exception to be associated with this queue.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public void Enqueue(TElement value)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Enqueue(`0)\">\r\n    <summary>\r\n    Adds an element to the tail of the queue.\r\n    </summary>\r\n    <param name=\"value\">The value to add.</param>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Enqueue(`0)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Enqueue(`0)\">\r\n    <summary>\r\n    Adds an element to the tail of the queue.\r\n    </summary>\r\n    <param name=\"value\">The value to add.</param>\r\n</member>\r\n"
            },
            {
              "Syntax": {
                "Content": "public Task<TElement> DequeueAsync(CancellationToken cancellationToken)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets a task whose result is the element at the head of the queue. If the queue\r\n    is empty, waits for an element to be enqueued. If <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete\"/> is called\r\n    before an element becomes available, the returned task is cancelled. If\r\n    <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(Exception)\"/> is called before an element becomes available, the\r\n    returned task throws that exception.\r\n    </summary>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync(CancellationToken)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.DequeueAsync(CancellationToken)\">\r\n    <summary>\r\n    Gets a task whose result is the element at the head of the queue. If the queue\r\n    is empty, waits for an element to be enqueued. If <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.Complete\"/> is called\r\n    before an element becomes available, the returned task is cancelled. If\r\n    <see cref=\"M:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1.SetException(Exception)\"/> is called before an element becomes available, the\r\n    returned task throws that exception.\r\n    </summary>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public sealed partial class AsyncQueue<TElement>",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\">\r\n    <summary>\r\n    A thread-safe, asynchronously dequeuable queue.\r\n    </summary>\r\n    <typeparam name=\"TElement\">The type of values kept by the queue.</typeparam>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1\">\r\n    <summary>\r\n    A thread-safe, asynchronously dequeuable queue.\r\n    </summary>\r\n    <typeparam name=\"TElement\">The type of values kept by the queue.</typeparam>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public class AnalyzerOptions",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions",
          "XmlDocumentation": ""
        }
      ],
      "Id": "N:Microsoft.CodeAnalysis.Diagnostics",
      "XmlDocumentation": ""
    },
    {
      "Classes": [
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "protected virtual string GetDebuggerDisplay()",
                "XmlDocumentation": ""
              },
              "Id": "M:Microsoft.CodeAnalysis.Emit.EmitResult.GetDebuggerDisplay",
              "XmlDocumentation": ""
            }
          ],
          "Syntax": {
            "Content": "public class EmitResult",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Emit.EmitResult\">\r\n    <summary>\r\n    The result of the Compilation.Emit method.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Emit.EmitResult",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Emit.EmitResult\">\r\n    <summary>\r\n    The result of the Compilation.Emit method.\r\n    </summary>\r\n</member>\r\n"
        },
        {
          "Methods": [],
          "Syntax": {
            "Content": "public sealed class EmitDifferenceResult",
            "XmlDocumentation": ""
          },
          "Id": "T:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult",
          "XmlDocumentation": ""
        },
        {
          "Methods": [
            {
              "Syntax": {
                "Content": "public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, LocalVariableNameProvider localNames)",
                "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider)\">\r\n    <summary>\r\n    Creates an <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/> from the metadata of the module before editing\r\n    and from a function that maps from a method to an array of local names. \r\n    </summary>\r\n    <param name=\"module\">The metadata of the module before editing.</param>\r\n    <param name=\"localNames\">\r\n    A function that returns the array of local names given a method index from the module metadata.\r\n    </param>\r\n    <returns>An <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/> for the module.</returns>\r\n    <remarks>\r\n    Only the initial baseline is created using this method; subsequent baselines are created\r\n    automatically when emitting the differences in subsequent compilations.\r\n    \r\n    When an active method (one for which a frame is allocated on a stack) is updated the values of its local variables need to be preserved.\r\n    The mapping of local variable names to their slots in the frame is not included in the metadata and thus needs to be provided by \r\n    <paramref name=\"localNames\"/>.\r\n    \r\n    The <see cref=\"T:Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider\"/> is only needed for the initial generation. The mapping for the subsequent generations\r\n    is carried over through <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/>. The compiler assigns slots to named local variables (including named temporary variables)\r\n    it the order in which they appear in the source code. This property allows the compiler to reconstruct the local variable mapping \r\n    for the initial generation. A subsequent generation may add a new variable in between two variables of the previous generation. \r\n    Since the slots of the previous generation variables need to be preserved the only option is to add these new variables to the end.\r\n    The slot ordering thus no longer matches the syntax ordering. It is therefore necessary to pass <see cref=\"P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.Baseline\"/>\r\n    to the next generation (rather than e.g. create new <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/>s from scratch based on metadata produced by subsequent compilations).\r\n    </remarks>\r\n</member>\r\n"
              },
              "Id": "M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider)",
              "XmlDocumentation": "<member name=\"M:Microsoft.CodeAnalysis.Emit.EmitBaseline.CreateInitialBaseline(Microsoft.CodeAnalysis.ModuleMetadata,Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider)\">\r\n    <summary>\r\n    Creates an <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/> from the metadata of the module before editing\r\n    and from a function that maps from a method to an array of local names. \r\n    </summary>\r\n    <param name=\"module\">The metadata of the module before editing.</param>\r\n    <param name=\"localNames\">\r\n    A function that returns the array of local names given a method index from the module metadata.\r\n    </param>\r\n    <returns>An <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/> for the module.</returns>\r\n    <remarks>\r\n    Only the initial baseline is created using this method; subsequent baselines are created\r\n    automatically when emitting the differences in subsequent compilations.\r\n    \r\n    When an active method (one for which a frame is allocated on a stack) is updated the values of its local variables need to be preserved.\r\n    The mapping of local variable names to their slots in the frame is not included in the metadata and thus needs to be provided by \r\n    <paramref name=\"localNames\"/>.\r\n    \r\n    The <see cref=\"T:Microsoft.CodeAnalysis.Emit.LocalVariableNameProvider\"/> is only needed for the initial generation. The mapping for the subsequent generations\r\n    is carried over through <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/>. The compiler assigns slots to named local variables (including named temporary variables)\r\n    it the order in which they appear in the source code. This property allows the compiler to reconstruct the local variable mapping \r\n    for the initial generation. A subsequent generation may add a new variable in between two variables of the previous generation. \r\n    Since the slots of the previous generation variables need to be preserved the only option is to add these new variables to the end.\r\n    The slot ordering thus no longer matches the syntax ordering. It is therefore necessary to pass <see cref=\"P:Microsoft.CodeAnalysis.Emit.EmitDifferenceResult.Baseline\"/>\r\n    to the next generation (rather than e.g. create new <see cref=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\"/>s from scratch based on metadata produced by subsequent compilations).\r\n    </remarks>\r\n</member>\r\n"
            }
          ],
          "Syntax": {
            "Content": "public sealed class EmitBaseline",
            "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\">\r\n    <summary>\r\n    Represents a module from a previous compilation. Used in Edit and Continue\r\n    to emit the differences in a subsequent compilation.\r\n    </summary>\r\n</member>\r\n"
          },
          "Id": "T:Microsoft.CodeAnalysis.Emit.EmitBaseline",
          "XmlDocumentation": "<member name=\"T:Microsoft.CodeAnalysis.Emit.EmitBaseline\">\r\n    <summary>\r\n    Represents a module from a previous compilation. Used in Edit and Continue\r\n    to emit the differences in a subsequent compilation.\r\n    </summary>\r\n</member>\r\n"
        }
      ],
      "Id": "N:Microsoft.CodeAnalysis.Emit",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:System.Security",
      "XmlDocumentation": ""
    },
    {
      "Classes": [],
      "Id": "N:Microsoft.CodeAnalysis.Emit.NoPia",
      "XmlDocumentation": ""
    }
  ],
  "Id": "Microsoft.CodeAnalysis",
  "MscorlibVersion": {}
}